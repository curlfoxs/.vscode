"use strict";

var tern = require('../lib/tern');
var complete = require('./ext/lib/complete');
var FileProcessor = require('./ext/lib/FileProcessor');
var TypeUtil = require('./ext/lib/TypeUtil');
var indexes = require('./ext/lib/indexes');
var IndexUtil = require('./ext/lib/IndexUtil');
var fs = require('fs');
var visibility = require('./ext/lib/visibility');
var _ = require('lodash');
var purge = require('./ext/lib/purge');
var config = require('./ext/lib/config');
var referenceAt = require('./ext/lib/referenceAt');
var appFor = require('./ext/lib/appFor');
var namespaceFor = require('./ext/lib/namespaceFor');
var urlFor = require('./ext/lib/urlFor');
var infer = require('../lib/infer');

var fileProcessor;

tern.registerPlugin("ext", function(server, options) {

    // prevent tern from resetting after a fixed number of uses
    Object.defineProperty(server, 'uses', {
        get: function() { return 0; },
        set: function() {}
    });

    return {
        passes: {
            describeType: function(found, doDescribe) {
                // TODO if found.node is method argument, return doDescribe(callExpression) passing parent call expression, otherwise do nothing
                var node, resultParams = [], isCallExpression = false, currIndex = -1;
                if (found) {
                    if (found.node && found.node.parent && found.node.parent.type === 'CallExpression') {
                        node = found.node.parent.callee;
                        isCallExpression = true;

                        //find current index of the found node in method parameters
                        var parentArgs = node.parent.arguments;
                        if (parentArgs) {
                            for(var a=0; a < parentArgs.length; a++) {
                                var argNode = parentArgs[a];
                                if (argNode === found.node) {
                                    currIndex = a;
                                }
                            }
                        }
                    } else {
                        node = found.node;
                    }
                    var result = doDescribe({node: node, state: found.state});
                    if (result.type) {
                        result.type = result.type.replace(/.prototype/g, '');
                        if (isCallExpression) {
                            var resultType = result.type, returnType;

                            if (resultType.indexOf('->') !== -1) {
                                var resultArr = resultType.split('->');
                                resultType = resultArr[0];
                                returnType = resultArr[1];
                            }

                            var paramStr = resultType.substring(resultType.indexOf('(') + 1, resultType.lastIndexOf(')'));
                            var paramArr = [];

                            if (paramStr && paramStr.indexOf(',') !== -1) {
                                paramArr = paramStr.split(',');
                            } else {
                                paramArr.push(paramStr);
                            }

                            for(var i=0; i < paramArr.length; i++) {
                                var param = paramArr[i].split(':');
                                var paramName = _.trim(param[0]);
                                var paramType = _.capitalize(_.trim(param[1]));
                                var paramItem = {"name" : paramName, "type": paramType};
                                if (i == currIndex) {
                                    paramItem.current = true;
                                }
                                resultParams.push(paramItem);
                            }
                            
                            if (returnType) {
                                result.return = {"type": _.trim(returnType)};
                            }

                            result.type = 'function()';
                            result.params = resultParams;
                            return result;
                        } else {
                            return result;
                        }
                    }
                }
            },
            request: function(url) {
                switch(url.pathname) {
                    case '/app':
                        return appFor(url.query.path);
                    case '/namespace':
                        return { namespace: namespaceFor(url.query.dir) };
                    case '/classes':
                        return infer.withContext(server.cx, function() {
                            visibility.setContext();
                            var matching = _.filter(indexes.className.keys(), function(k) { return k.toLowerCase().indexOf(url.query.name.toLowerCase()) !== -1 });
                            return _.flatten(matching.map(function(key) {
                                return indexes.className.get(key).map(function(cls) {
                                    return { name: cls.def.name, origin: cls.def.origin };
                                });
                            }));
                        });
                    case '/refresh':
                        server.reset();
                        return { success: true };
                }
            },
            postReset: function() {
                var options = config(server);
                server._ExtJS = { config: options };
                purge.wrap(server.cx.topScope);

                for (var i in indexes) {
                    var index = indexes[i];

                    if (index.persistent) {
                        index.pruneDeleted();
                    } else {
                        index.clear(); // prevent duplicate entries when reindexing
                    }
                }

                fileProcessor = new FileProcessor(this, options);
            },
            scopeAt: require('./ext/lib/scopeFor'),
            delFile: function(file) {
                if (!file.match(/\.js$/) && indexes.file.keys().some(function(k) { return k.indexOf(file) === 0 })) {
                    // reset when a directory containing indexed files is deleted
                    server.reset();
                    return true;
                }
            },
            purge: function(origins) {
                if (fileProcessor) fileProcessor.purge(origins);
            },
            findDef: function(file, query) {
                visibility.setContext(file.name);
                var ref = referenceAt(file, tern.resolvePos(file, query.end));
                return ref && ref.findDef();
            },
            findDocs: function(type, file, result) {
                var url;

                if (result && result.url && result.origin) {
                    url = urlFor(result.origin, result.url.className, result.url);
                } else {
                    // if tern could not come up with a url, go to the fallback url for the current SDK and toolkit
                    url = urlFor(file.name);
                }

                if (url) return { url: url };
            },
            completion: function(file, query) {
                visibility.setContext(file.name);
                return complete(file, query);
            },
            postParse: function(ast, text) {
                fileProcessor.postParse(ast, text);
            },
            beforeLoad: function(file) {
                return fileProcessor.beforeLoad(file);
            },
            preInfer: function(ast, text) {
                visibility.setContext(ast.sourceFile.name);
                fileProcessor.infer(ast, text, true)
            }
        }
    };
});

