"use strict";

var IndexUtil = require('./IndexUtil');
var ASTUtil = require('./ASTUtil');
var TypeUtil = require('./TypeUtil');
var indexes = require('./indexes');
var tern = require('../../../lib/tern');
var infer = require('../../../lib/infer');
var _ = require('lodash');
var cmdAutoDependencies = require('./cmdAutoDependencies');
var findInComponentTree = require('./findInComponentTree');
var appFor = require('./appFor');
var ref = require('./ref');
var walk = require('acorn/dist/walk');

/**
 * Returns the appropriate type of reference for the given position in the file
 * @param {Object} file A file object
 * @param {Integer} pos The position of the reference in the file
 * @returns {Reference}
 */
module.exports = function referenceAt(file, pos) {
    var found = walk.findNodeAround(file.ast, pos);

    if (!found) return;

    var node = found.node,
        type = node.type;

    if (isObjectKey(node, pos)) {
        if (node.type === 'Identifier') node = node.parent;

        var parentProperty = ASTUtil.getParentOfType(node, 'Property'),
            parentPropertyName = parentProperty && parentProperty.key.name;

        // object keys
        if (parentPropertyName === 'listeners') {
            // event
            return new ref.Event(node);
        } else {
            // configs
            return new ref.Config(node);
        }
    } else {
        if (node.type === 'ObjectExpression') {
            // will get here in the following case:
            //  xtype: <caret>
            // acorn doesn't assign an AST node to an empty value, but we should be completing values here, not keys
            found = walk.findNodeBefore(node, pos);
            if (!found) return;
            node = found.node;
        } else if (node.type === 'Identifier' && node.parent && node.parent.type === 'Property') {
            // will get here in the following case:
            //  xtype: pa<caret>
            node = node.parent;
        }

        if (node.type === 'Property') {
            var reference = referenceForPropertyValue(node.key.name, node, node);
            reference.wrapInQuotes = true;
            return reference;
        } else if (type === 'Literal') {
            if (ref.BindExpression.isBindExpression(node, pos)) {
                // view model bind expressions
                return new ref.BindExpression(node, pos);
            } else if (node.parent) {
                var parent = node.parent.type === 'ArrayExpression' ? node.parent.parent : node.parent;

                if (parent.type === 'Property') {
                    // property values
                    return referenceForPropertyValue(parent.key.name, node, parent);
                } else if (node.parent.type === 'CallExpression') {
                    // method parameters
                    return referenceForParam(node, file.ast, pos);
                }
            }
        } else if (type === 'CallExpression') {
            return referenceForParam(node, file.ast, pos);
        }

        // when in doubt - maybe it matches a class?
        return new ref.Class(node);
    }
}

/**
 * Returns true if the position is an object key
 * @param {Node} node The node at the given position
 * @param {Integer} pos The exact offset
 * @returns {Boolean}
 */
function isObjectKey(node, pos) {
    var file = node.sourceFile,
        type = node.type;

    return  (type === 'Property' || type === 'ObjectExpression' || (type === 'Identifier' && node.parent && node.parent.type === 'Property' && node.parent.key.name === node.name)) &&
            !_.endsWith(_.trim(file.text.slice(0, pos)), ':'); /* empty property value */
}

/**
 * Returns a reference for the specified node which is the value of a property
 * @param {String} propName The property name
 * @param {Node} node The node to create a reference for
 * @param {Node} propertyNode The property node in which the above node resides
 * @returns {Reference}
 */
function referenceForPropertyValue(propName, node, propertyNode) {
    if ('xclass' === propName) return new ref.Class(node);

    if ('xtype' === propName && !TypeUtil.isExtDefine(ASTUtil.getParentOfType(node, 'CallExpression', 3))) {
        return new ref.Alias(node, cmdAutoDependencies['items']);
    }

    // grid fields
    if (propName === 'dataIndex') {
        return new ref.Field(node);
    }

    // store id
    if (propName === 'store') {
        return new ref.Store(node);
    }

    // handler event binding
    if (propName === 'handler') {
        return new ref.ControllerMethod(node);
    }

    var rule = cmdAutoDependencies[propName];

    if (!rule) {
        var parentProperty = ASTUtil.getParentPropertyName(propertyNode);
        if (parentProperty) rule = cmdAutoDependencies[parentProperty];
        if (rule && (rule.typeProperty || ['type']).indexOf(propName) === -1) rule = undefined;
    }

    // alias and mvc references
    if (rule) {
        return rule.mvc ? new ref.MVC(node, rule) : new ref.Alias(node, rule);
    }

    // view controller methods as event listeners
    if(propertyNode.parent.parent.type === 'Property' && propertyNode.parent.parent.key.name === 'listeners') {
        return new ref.ControllerMethod(node);
    }

    // when in doubt - maybe it matches a class?
    return new ref.Class(node);
}

/**
 * Returns a reference for the specified node which is a function parameter
 * @param {Node} node
 * @param {Node} ast
 * @param {Integer} pos
 * @returns {Reference}
 */
function referenceForParam(node, ast, pos) {
    var call = node.type === 'Literal' ? node.parent : node,
        foundExpression = infer.findExpressionAround(ast, null, pos),
        result;

    if (foundExpression && call.type === 'CallExpression') {
        if (!call.callee.object || !call.callee.property) return;

        if (['on', 'mon', 'un', 'mun'].indexOf(call.callee.property.name) !== -1) {
            // event names
            result = new ref.Event(node, typesAt(ast, call.callee.object, foundExpression.state));
        } else if (['lookupReference', 'lookup'].indexOf(call.callee.property.name) !== -1) {
            result = new ref.ViewComponentReference(node);
        }

        // Ext.widget
        if (ASTUtil.getFullyQualifiedName(call.callee) === 'Ext.widget') {
            result = new ref.Alias(node, cmdAutoDependencies['items']);
        }
    }

    if (result) {
        if (node.type !== 'Literal') result.wrapInQuotes = true;
        return result;
    } else {
        // when in doubt - maybe it matches a class?
        return new ref.Class(node);
    }
}

/**
 * Returns the types of the given node
 * @param {Node} ast The full AST tree
 * @param {Node} node The node whose type should be returned
 * @param {Object} state A scope
 * @returns {String[]}
 */
function typesAt(ast, node, state) {
    var type = infer.typeFromContext(ast, { node: node, state: state }),
        classNames = [];

    if (type) {
        var protos = type instanceof infer.AVal ? type.types : [type.proto];

        protos.forEach(function(proto) {
            if (proto.extJSClass) {
                classNames.push(proto.extJSClass.name);
            }
        });
    }

    return classNames;
}
