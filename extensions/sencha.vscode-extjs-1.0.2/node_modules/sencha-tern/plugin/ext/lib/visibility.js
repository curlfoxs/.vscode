var toolkitFor = require('./toolkitFor'),
    appFor = require('./appFor'),
    util = require('./util'),
    infer = require('../../../lib/infer'),
    _ = require('lodash');

var currentApp, currentToolkit, currentFile;

module.exports = {

    /**
     * Sets the current file visibility context
     * @param {String} file The current file open in the IDE
     * @returns {Object} The result of the callback
     */
    setContext: function(file) {
        global.tern.unleashTheFury = true;
        global.tern.requestCache = {};
        currentFile = file;

        if (file) {
            currentApp = appFor(file);
            currentToolkit = toolkitFor(file);
        }
    },

    /**
     * Return true if the thing specified in the first argument is visible
     * @param {String/infer.Obj/infer.Aval} thing A file path or tern model object
     * @returns {boolean}
     */
    isVisible: function(thing) {
        if (!thing) throw new Error('first argument cannot be null in call to visibility.isVisible');

        if (_.isString(thing)) {
            return isFileVisible(thing);
        } else if (thing instanceof infer.AVal) {
            return _.find(thing.types, isTypeVisible);
        } else if (thing instanceof infer.Obj) {
            return isTypeVisible(thing);
        } else {
            return true;
        }
    },

    /**
     * Returns true if the file is in the same app as the current file
     * @param file
     * @returns {boolean}
     */
    isInCurrentApp: function(file) {
        var app = appFor(file);
        if (app && app.sdk && app.sdk.path && file.indexOf(app.sdk.path) === 0) return false;
        return currentApp === app;
    }
};

/**
 * Returns true if the file is visible from the current context
 * @param {String} file A file path
 * @returns {boolean}
 */
function isFileVisible(file) {
    if (!file || !currentFile) return true;

    var fileToolkit = toolkitFor(file),
        app = appFor(file);

    // if for some reason no app can be found, default to classic (older projects lacking proper structure tend to be classic)
    if (app === undefined && fileToolkit === 'classic') return true;

    // the file must be in the same toolkit as the open file or in the core toolkit
    if (['core', currentToolkit].indexOf(fileToolkit) === -1) return false;

    // the files must either be in the same app or neither be in an app
    if (currentApp == app) return true;

    // all files in the app's sdk are visible if they are in the right toolkit
    if (currentApp && currentApp.sdk && currentApp.sdk.path && util.startsWithIgnoreCase(file, currentApp.sdk.path)) return true;

    // files not tied to an app or sdk are always visible
    if (!app && !isInSdk(file)) return true;

    return false;
}

/**
 * For files in an sdk, returns the path to the root of the sdk
 * @param {String} file
 * @returns {Boolean}
 */
function isInSdk(file) {
    var apps = global.tern.apps;

    for (var i=0; i<apps.length; i++) {
        var app = apps[i];
        if (app.sdk && app.sdk.path && util.startsWithIgnoreCase(file, app.sdk.path)) return true;
    }

    return false;
}

/**
 * Returns true if the specified type has a visible origin
 * @param {infer.Obj} type
 * @returns {boolean}
 */
function isTypeVisible(type) {
    if (type.extJSClass && type.extJSClass.def.private && !util.equalsIgnoreCase(type.origin, currentFile)) {
        return false; // hide private classes unless the user is in the file where the class is defined
    } else if (type.origin) {
        return isFileVisible(type.origin);
    } else if (type.gatherProperties) {
        var props = [];
        type.gatherProperties(function(prop) { props.push(prop) }, 0);
        return props.length > 0;
    } else {
        return true;
    }
}
