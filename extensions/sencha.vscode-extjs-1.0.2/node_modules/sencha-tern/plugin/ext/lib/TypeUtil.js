"use strict";

var infer = require('../../../lib/infer');
var ASTUtil = require('./ASTUtil');
var _ = require('lodash');
var walk = require('acorn/dist/walk');
var indexes = require('./indexes');
var IndexUtil = require('./IndexUtil');
var cmdAutoDependencies = require('./cmdAutoDependencies');


// get all type properties for aliases
var typeProperties = ['type'];
for (var key in cmdAutoDependencies) {
    var rule = cmdAutoDependencies[key];
    if (rule.typeProperty) typeProperties = typeProperties.concat(rule.typeProperty);
}
typeProperties = _.uniq(typeProperties);

var factoryMethods = ['Ext.create', 'Ext.widget', 'Ext.createByAlias'];

/**
 * Extracts a fully qualified name from a tree of memberExpressions
 * @param {Node} memberExpression
 * @returns {String}
 */
function getFullyQualifiedName(memberExpression) {
    if (memberExpression.name) return memberExpression.name;
    return getFullyQualifiedName(memberExpression.object) + '.' + memberExpression.property.name;
}

/**
 * Creates an implicit type with the specified typeProperty as a member.  This allows us to include the correct
 * type config name when completing configs
 * @param {String[]} typeProperties
 * @returns {Object}
 */
function createImplicitType(typeProperties) {
    var implicitType = { members: {} };

    for (var i=0; i<typeProperties.length; i++) {
        var prop = typeProperties[i];
        implicitType.members[prop] = { name: prop, type: 'String', access: 'public' };
    }

    return implicitType;
}

/**
 * Returns the @cmd-auto-dependency rule for the specified property
 * @param {Property} property A property node
 * @returns {Object}
 */
function getRule(property) {
    if (!property || property.type !== 'Property') return;

    if (typeProperties.indexOf(property.key.name) !== -1) {
        property = ASTUtil.getParentOfType(property, 'Property');
    }

    if (property && property.key) {
        return cmdAutoDependencies[property.key.name];
    }
}

/**
 * Returns the names of classes return by the specified function call
 * @param {Node} call A call expression
 * @returns {String[]} class names returned by the function
 */
function typesReturnedByFactoryMethod(call) {
    var args = call.arguments;
    if (args.length < 1) return [];
    var firstArg = args[0], argType = firstArg.type;

    if (TypeUtil.isExtCreate(call)) {
        if (argType === 'Literal') {
            return [firstArg.value]; // first argument should be a class name string literal
        } else if (argType === 'ObjectExpression') {
            var xtype = ASTUtil.findPropertyValue(firstArg, 'xtype');

            if (xtype) {
                return TypeUtil.classesForAlias('widget.' + xtype);
            } else {
                var xclass = ASTUtil.findPropertyValue(firstArg, 'xclass');
                if (xclass) return [xclass];
            }
        }
    } else if (argType === 'Literal') {
        if (TypeUtil.isExtWidget(call)) {
            return TypeUtil.classesForAlias('widget.' + args[0].value);
        } else if (TypeUtil.isExtCreateByAlias(call)) {
            return TypeUtil.classesForAlias(args[0].value);
        }
    }

    return [];
}

/**
 * Given an object, finds a rule with isKeyedObject: true for the property
 * to which the parent object is assigned
 * @param {Node} obj An ObjectExpression node
 * @returns {Object} A rule from cmdAutoDependencies
 */
function findKeyedObjectRuleForParent(obj) {
    if (obj.type !== 'ObjectExpression') return;
    obj = obj.parent;
    if (!obj || obj.type !== 'Property') return;
    obj = obj.parent;
    if (!obj || obj.type !== 'ObjectExpression') return;
    rule = cmdAutoDependencies[ASTUtil.getParentPropertyName(obj)];
    return rule && rule.isKeyedObject ? rule : null;
}

var TypeUtil = {

    /**
     * Determines the classes of the object returned by the specified call
     * @param {ObjectExpression} obj
     * @return {String[]}
     */
    typesOf: function(obj) {
        if (!obj) return [];

        if (obj.type !== 'ObjectExpression') obj = ASTUtil.getParentOfType(obj, 'ObjectExpression');

        if (ASTUtil.isConfigObject(obj)) return TypeUtil.typesOf(obj.parent.parent);

        var types = [];

        if (TypeUtil.isExtDefine(obj.parent)) {
            types.push('Ext.Class');
            if (obj.parent.arguments.length > 1) types.push(obj.parent.arguments[0].value);
        } else {
            var xtype = ASTUtil.findPropertyValue(obj, 'xtype');

            if (xtype) {
                types = types.concat(TypeUtil.classesForAlias('widget.' + xtype));
            } else {
                var call = ASTUtil.getParentOfType(obj, 'CallExpression');

                if (call && call.arguments.indexOf(obj) !== -1) {
                    types = types.concat(typesReturnedByFactoryMethod(call));
                } else if (obj.parent && obj.parent.type === 'NewExpression') {
                    types.push(getFullyQualifiedName(obj.parent.callee));
                } else {
                    var parentProperty = ASTUtil.getParentPropertyName(obj);

                    if (parentProperty) {
                        var rule = cmdAutoDependencies[parentProperty] || findKeyedObjectRuleForParent(obj);

                        if (rule) {
                            if (rule.directRef) {
                                types.push(rule.directRef);
                            } else {
                                var typeProperty = rule.typeProperty || ['type'];
                                var alias = ASTUtil.findPropertyValue(obj, typeProperty) || rule.defaultType;
                                types.push(createImplicitType(typeProperty));

                                if (alias) {
                                    var type = TypeUtil.classesForAlias(rule.aliasPrefix + alias);
                                    if (type) types = types.concat(type);
                                }
                            }
                        } else {
                            // get type from parent property's cfg tag
                            var parentObj = ASTUtil.getParentOfType(obj, 'ObjectExpression', 2);

                            if (parentObj) {
                                TypeUtil.typesOf(parentObj).forEach(function(t) {
                                    IndexUtil.findPrototypes(t).forEach(function(c) {
                                        if (c.extJSClass) {
                                            // try to get type from config
                                            var parentConfig = c.extJSClass.getConfigs()[parentProperty];
                                            if (parentConfig && parentConfig.type) types = types.concat(toTypeArray(parentConfig.type));

                                            // try to get type from property of same name - this works in some cases, for example with Ext.data.Model#schema
                                            var prop = c.props[parentProperty];
                                            if (prop && prop.types) prop.types.forEach(function(t) {
                                                t.types && t.types.forEach(function(t) {
                                                    if (t.extJSClass) types.push(t.extJSClass.name);
                                                })
                                            });
                                        }
                                    })
                                })
                            }
                        }
                    }
                }
            }
        }

        // add Ext.Panel if no explicit types are found.
        if (!_.find(types, function(t) { return typeof(t) === 'string' })) types.push('Ext.Panel');

        return types;
    },

    /**
     * Returns true if the specified call is to Ext.create
     * @param {Node} call
     * @returns {boolean}
     */
    isExtCreate: function(call) {
        return TypeUtil.isCallTo(call, 'Ext.create');
    },

    /**
     * Returns true if the specified call is to Ext.define
     * @param {Node} call
     * @returns {boolean}
     */
    isExtDefine: function(call) {
        return TypeUtil.isCallTo(call, 'Ext.define');
    },

    /**
     * Returns true if the specified call is to Ext.widget
     * @param {Node} call
     * @returns {boolean}
     */
    isExtWidget: function(call) {
        return TypeUtil.isCallTo(call, 'Ext.widget');
    },

    /**
     * Returns true if the specified call is to Ext.apply
     * @param {Node} call
     * @returns {boolean}
     */
    isExtApply: function(call) {
        return TypeUtil.isCallTo(call, 'Ext.apply');
    },

    /**
     * Returns true if the specified call is to Ext.createByAlias
     * @param {Node} call
     * @returns {boolean}
     */
    isExtCreateByAlias: function(call) {
        return TypeUtil.isCallTo(call, 'Ext.createByAlias');
    },

    /**
     * Returns true if the specified call creates an instance of an Ext object. (Ext.create, Ext.widget, or constructor call)
     * @param {Node} call
     * @returns {Boolean}
     */
    createsInstance: function(call) {
        var name = ASTUtil.getFullyQualifiedName(call.callee);
        return factoryMethods.indexOf(name) !== -1 || ASTUtil.isConstructorCall(call);
    },

    /**
     * Returns true if the specified call is to the method with the specified name
     * @param {Node} call The call node
     * @param {String} name The fully qualified method name:  For example:  Ext.Array#clone
     * @returns {Boolean}
     */
    isCallTo: function(call, name) {
        return call && name === ASTUtil.getFullyQualifiedName(call.callee);
    },

    /**
     * Returns the canonical class names for the specified alias
     * @param {String} alias
     * @returns {String[]}
     */
    classesForAlias: function(alias) {
        return indexes.alias.get(alias) || [];
    },

    /**
     * Creates an aval type for the specified class names
     * @param {String[]} classNames
     * @returns {infer.AVal}
     */
    createAVal: function(classNames) {
        var result = new infer.AVal();

        for (var i=0; i<classNames.length; i++) {
            var protos = IndexUtil.findPrototypes(classNames[i]);

            for (var p=0; p<protos.length; p++) {
                result.addType(protos[p]);
            }
        }

        return result;
    },

    /**
     * Provides code completion for configs in object literals
     * @param {Object[]/String[]} types
     * @param {String} memberType
     * @param {Function} [format]
     * @returns {Array} arrays of objects with name and type
     */
    getMembers: function(types, memberType, format) {
        var getter = 'get' + _.capitalize(memberType) + 's',
            members = {},
            implicitMembers = {};

        types.forEach(function(className) {
            if (_.isObject(className)) {
                _.assign(implicitMembers, className.members);
            } else {
                IndexUtil.findPrototypes(className).forEach(function(proto) {
                    if (proto.extJSClass) {
                        _.assign(members, proto.extJSClass[getter]());
                    }
                });
            }
        });

        // defined members should overwrite implicit members, otherwise we'll get duplicates such as "xtype"
        members = _.extend(implicitMembers, members);

        if (format) {
            return Object.keys(members).map(function(name) {
                return format(name, members[name]);
            });
        } else {
            return _.values(members);
        }
    },

    /**
     * Returns the Ext.define class in which the class resides
     * @param {Node} node Any node inside a class definition
     * @returns {Node} A CallExpression node (Ext.define)
     */
    getEnclosingClassNode: function(node) {
        while (node && !TypeUtil.isExtDefine(node)) node = node.parent;
        return node;
    },

    /**
     * Returns the name of the class in which the node resides
     * @param {Node} node Any node in a class definition
     * @returns {String}
     */
    getEnclosingClassName: function(node) {
        var classNode = TypeUtil.getEnclosingClassNode(node);
        return classNode && classNode.arguments[0] && classNode.arguments[0].value;
    },

    /**
     * Returns types at given origin and span
     * @param {String} origin origin file name
     * @param {String} span
     * @returns {*|infer.AVal}
     */
    typesAt: function(origin, span) {
        var ast = ASTUtil.parse(origin, span);
        return this.createAVal(this.typesOf(ast));
    }
};

/**
 * Converts a '/' delimited string to an array of class names, removing [] where present
 */
function toTypeArray(typesStr) {
    return typesStr.split('/').map(function(t) {
        return t.replace('[]', '');
    })
}

module.exports = TypeUtil;