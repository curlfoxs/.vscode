var appFor = require('./appFor'),
    cmdAutoDependencies = require('./cmdAutoDependencies'),
    infer = require('../../../lib/infer'),
    IndexUtil = require('./IndexUtil'),
    TypeUtil = require('./TypeUtil'),
    _ = require('lodash');

/**
 * Returns the scope for the specified ast node.  Returns null if no scope can be found.
 * @param {Node} ast
 * @param {Integer} pos
 * @returns {infer.AVal}
 */
module.exports = function(ast, pos) {
    var found = infer.findExpressionAround(ast, null, pos);
    if (!found) return;
    var node = found.node;

    if (node.type === 'Literal' && node.parent) {
        var scope;

        if (node.parent.type === 'ArrayExpression') node = node.parent;

        if (node.parent.type === 'Property') {
            var rule = cmdAutoDependencies[node.parent.key.name];

            // provide custom scope for mvc references
            if (rule && rule.mvc) {
                var app = appFor(node);
                if (!app) return;
                var namespace = appFor(node).name + '.' + rule.aliasPrefix.replace(/\.$/, '');
                scope = IndexUtil.findObjects(namespace)[0] || new infer.Obj();
            }
        } else if (TypeUtil.isExtCreate(node.parent)) {
            scope = new infer.Obj();

            _.extend(scope.props, global.tern.aliasScope.props, _.pick(infer.cx().topScope.props, function(value, key) {
                return value.sencha;
            }));
        }

        if (!scope) scope = infer.cx().topScope; // This allows class name completion to work in strings

        scope.includeKeywords = false;
        return scope;
    }
};

