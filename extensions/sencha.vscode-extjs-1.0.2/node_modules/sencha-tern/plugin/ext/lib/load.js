"use strict";

var _ = require('lodash');
var infer = require('../../../lib/infer');
var IndexUtil = require('./IndexUtil');
var indexes = require('./indexes');
var TypeUtil = require('./TypeUtil');
var fs = require('fs');
var purge = require('./purge');
var visibility = require('./visibility');
var Namespace = require('./Namespace');
var ASTUtil = require('./ASTUtil');
var ref = require('./ref');
var util = require('./util');

var tern = require('../../../lib/tern');
/**
 * Loads a json type definition
 * @param {Object} data A json type definition
 * @param {Object} plugin The Ext JS tern plugin
 */
module.exports = function(data, plugin) {
    new Loader(data, plugin).load();
};

/**
 * Creates type definitions for Ext JS classes.  This class should not have any dependencies to tern, only the ast
 * class from acorn - that way it can be pulled out into a seperate package later if we decide to use this as a replacement
 * for jsduck.
 * @param {Object} data Class data created by the Extractor
 * @constructor
 */
function Loader(data) {
    if (!global.tern.aliasScope) global.tern.aliasScope = new infer.Obj();

    this.id = id++;
    this.def = data;
    this.cx = infer.cx();
    this.scope = this.cx.topScope;
    this.name = data.name;
    this.shortName = this.getShortName(this.name);
    this.proto = new infer.Obj(true, this.shortName + '.prototype');
    this.proto.sencha = true;

    // we get relative paths during eager loading, absolute paths for incremental updates - need to make sure they
    // are the same so we don't get stale copies of classes
    this.cx.curOrigin = this.def.origin;
}

/**
 * A map of lower-case Ext JS types to TernJS types
 * @type {{boolean: string}}
 */
var PRIMITIVE_TYPES = {
    integer: 'num',
    number: 'num',
    string: 'str',
    boolean: 'bool'
};

/**
 * Retruns ViewController references
 * @param {String} args
 * @param {Node} argNodes
 * @returns {*|infer.ANull}
 */
function lookupViewReferences(args, argNodes) {
    if (args === null || argNodes === null) return infer.ANull;
    var result = new infer.AVal();
    if (args.length < 1 || argNodes.length < 1) return result;
    var arg0 = argNodes[0];

    if (arg0.type === 'Literal') {
        new ref.ViewComponentReference(arg0).findDef().forEach(function(def) {
            result.addType(TypeUtil.typesAt(def.origin, def.span))
        });
    }

    return result;
}

/**
 * Compute return types for factory functions
 */
var customReturnTypes = {
    'Ext#create': function(_self, args, argNodes) {
        if (args === null || argNodes === null) return infer.ANull;
        if (args.length < 1 || argNodes.length < 1) return infer.ANull;
        var arg0 = argNodes[0];

        if (arg0.type === 'ObjectExpression') {
            return TypeUtil.createAVal(TypeUtil.typesOf(arg0));
        } else if (arg0.type === 'Literal') {
            return TypeUtil.createAVal([arg0.value]);
        } else {
            return new infer.AVal();
        }
    },
    'Ext#createByAlias': function(_self, args, argNodes) {
        if (args === null || argNodes === null) return infer.ANull;
        if (args.length < 1 || argNodes.length < 1) return infer.ANull;
        var arg0 = argNodes[0];

        if (arg0.type === 'Literal') {
            return TypeUtil.createAVal(TypeUtil.classesForAlias(arg0.value));
        } else {
            return new infer.AVal();
        }
    },
    'Ext#widget': function(_self, args, argNodes) {
        if (args === null || argNodes === null) return infer.ANull;
        if (args.length < 1) return infer.ANull;
        var alias = argNodes && argNodes[0] && argNodes[0].value
        if (!alias) return infer.ANull;
        return TypeUtil.createAVal(TypeUtil.classesForAlias('widget.' + alias));
    },
    'Ext#define': function(_self, args, argNodes) {
        if (args === null || argNodes === null) return infer.ANull;
        if (args.length < 1) return infer.ANull;
        var className = argNodes && argNodes[0].value;
        if (!className) return infer.ANull;
        var result = new infer.AVal();
        IndexUtil.findConstructors(className).forEach(function(con) { result.addType(con) });
        return result;
    },
    'Ext.app.ViewController#getView': function(_self) {
        var types = _self.types || [_self];
        var result = new infer.AVal();

        types.forEach(function(t) {
            t.extJSClass && t.extJSClass.def.aliases && t.extJSClass.def.aliases.forEach(function(alias) {
                alias = alias.replace('controller.', '');
                var usages = _.filter(indexes.usage.get(alias), function(entry) { return entry.property === 'controller' });

                usages.forEach(function(usage) {
                    var node = ASTUtil.parse(usage.file, usage.offset);

                    if (node) IndexUtil.findPrototypes(TypeUtil.getEnclosingClassName(node)).forEach(function(proto) {
                        result.addType(proto);
                    });
                });
            });
        });

        return result;
    },
    'Ext.app.ViewController#lookupReference' : function(_self, args, argNodes) {
        return lookupViewReferences(args, argNodes);
    },
    'Ext.app.ViewController#lookup' : function(_self, args, argNodes) {
        return lookupViewReferences(args, argNodes);
    },
    // Removed this for GA - too slow, especially since it winds up being called during analysis ina addition to code completion
    //'Ext.app.ViewController#getReferences' : function(_self) {
    //    var start = new Date();
    //    var types = _self.types || [_self];
    //    var refObj = new infer.Obj(true);
    //    types.forEach(function(t) {
    //        t.extJSClass && t.extJSClass.def.aliases && t.extJSClass.def.aliases.forEach(function(alias) {
    //            var refs = ref.ViewComponentReference.getViewReferencesForAlias(alias);
    //            refs.forEach(function(ref) {
    //                refObj.props[ref.name] = TypeUtil.typesAt(ref.origin, ref.span);
    //            });
    //        });
    //    });
    //    return refObj;
    //}
};

var doNothing = function() {};
var id = 0;

Loader.prototype = {

    /**
     * Extracts a type definition from the ast node and registers it as a class in the top scope.
     */
    load: function() {
        if (this.def.override) {
            indexes.override.put(this.def.name, this.def, this.def.origin);
        } else {
            _.assign(this.proto, {
                purge: doNothing,
                extJSClass: this
            });

            this.loadProperties();

            this.type = this.def.singleton ? this.proto : new infer.Fn(this.shortName, this.scope, [], [], this.proto);
            this.type.sencha = true;
            this.type.origin = this.proto.origin = this.def.origin;
            this.type.span = this.proto.span = this.def.span;
            this.type.extJSClass = this;
            this.type.url = this.proto.url = this.def.url;

            // index class name for /classes
            indexes.className.put(this.def.name, this, this.def.origin);

            // proxy props to return all inherited properties and methods
            Object.defineProperty(this.proto, 'props', { get: this.createInheritedPropertiesGetter() });

            // create a getter for statics
            if (!this.def.singleton) Object.defineProperty(this.type, 'props', { get: this.createStaticsGetter() });

            this.addToTopScope();
            this.addToAliasScope();
            this.index();
        }
    },

    /**
     * Creates a getter for infer.Obj#props that returns a union of all properties from each of the specified classes.
     * @returns {Function} A function that returns an object map of property name to property type
     */
    createInheritedPropertiesGetter: function() {
        return function() {
            if (!global.tern.unleashTheFury) return infer.cx().protos.Object.props; // don't fetch properties during the initial infer pass at startup, only during the completion pass, otherwise inferring takes forever

            var cacheKey = this.id + '_props',
                result = global.tern.requestCache[cacheKey];

            if (!result) {
                if (this.isVisible()) {
                    result = global.tern.requestCache[cacheKey] = {};

                    _.assign(result, this.properties, this.createPropertiesFromOverrides('properties'));

                    if (this.def.singleton) _.assign(result, this.createPropertiesFromOverrides('statics'));

                    this.getSuperClasses().forEach(function(name) {
                        IndexUtil.findPrototypes(name).forEach(function(proto) {
                            _.assign(result, proto.props)
                        });
                    });

                    // without this propagating the class as the scope in each method results in a crash
                    _.assign(result, this.cx.protos.Object.props);
                } else {
                    // without this propagating the class as the scope in each method results in a crash
                    result = global.tern.requestCache[cacheKey] = infer.cx().protos.Object.props;
                }
            }

            return result;
        }.bind(this);
    },

    /**
     * Creates a getter for infer.Fn#props that returns an object comprised of the prototype and all static properties
     * @returns {function(this:Extractor)}
     */
    createStaticsGetter: function() {
        return function() {
            var result = {};

            if (global.tern.unleashTheFury && this.isVisible()) { // don't fetch properties during the initial infer pass at startup, only during the completion pass, otherwise inferring takes forever
                _.assign(result, this.getStatics(false));
            }

            if (this.proto) {
                var aVal = new infer.AVal();
                aVal.addType(this.proto);
                result['prototype'] = aVal;
            }

            return result;
        }.bind(this);
    },

    /**
     * Returns an object of name => member definition containing all of the inheritable static members from this class and superclasses
     * @param {Boolean} onlyInheritable True to only include inheritable statics
     * @returns {Object}
     */
    getStatics: function(onlyInheritable) {
        var cacheKey = this.id + '_statics';
        var result = global.tern.requestCache[cacheKey];

        if (!result) {
            result = {};

            this.getSuperClasses().forEach(function (name) {
                IndexUtil.findConstructors(name).forEach(function (constructor) {
                    if (constructor.extJSClass) _.assign(result, constructor.extJSClass.getStatics(true));
                });
            });

            for (var name in this.statics) {
                var prop = this.statics[name];
                if (prop.inheritable || !onlyInheritable) result[name] = prop;
            }

            if (!onlyInheritable) {
                _.assign(result, this.createPropertiesFromOverrides('statics'))
            }

            global.tern.requestCache[cacheKey] = result;
        }

        return result;
    },

    /**
     * Creates tern property definitions for all properties declared in overrides
     * @param collection
     */
    createPropertiesFromOverrides: function(collection) {
        var properties = {},
            overrides = indexes.override.get(this.name);

        if (overrides) overrides.forEach(function(override) {
            for (var name in override[collection]) {
                var prop = this.createProperty(override[collection][name]);
                if (prop) properties[name] = prop;
            }
        }.bind(this));

        return properties;
    },

    /**
     * Returns all inherited configs
     * @returns {Object} configs The configs for the current class
     */
    getConfigs: function() {
        return this.getInherited('configs');
    },

    /**
     * Returns all inherited events
     * @returns {Object}
     */
    getEvents: function() {
        return this.getInherited('events');
    },

    /**
     * Gets all inherited members from the specified collection.
     * @param {String} collection The name of the collection on data (configs, events, etc...)
     * @param getter
     * @returns {Object}
     */
    getInherited: function(collection) {
        var cacheKey = this.name + '_' + collection;
        var result = global.tern.requestCache[cacheKey];

        if (result) return result;

        if (!this.isVisible()) return global.tern.requestCache[cacheKey] = {};

        var classNames = this.getSuperClasses(),
            result = _.assign({}, this.def[collection]);

        // add from overrides
        var overrides = indexes.override.get(this.name);
        if (overrides) overrides.forEach(function(override) {
            _.assign(result, override[collection])
        });

        classNames.forEach(function(name) {
            IndexUtil.findPrototypes(name).forEach(function(type) {
                if (type.extJSClass) {
                    _.assign(result, this.getInherited.call(type.extJSClass, collection));
                }
            }.bind(this));
        }.bind(this));

        if (collection === 'configs') this.def.hideConfigs.forEach(function(config) {
            delete result[config];
        });

        return global.tern.requestCache[cacheKey] = result
    },

    /**
     * Returns true if the class is visible from the current completion context's toolkit
     */
    isVisible: function() {
        return visibility.isVisible(this.def.origin);
    },

    /**
     * If properties have not yet been extracted from the config object, extract them.  This is time consuming, so
     * we delay it until the first completion of a class instance.
     */
    loadProperties: function() {
        if (!this.properties) {
            this.configs = {};
            this.properties = {};
            this.statics = {};

            for (var name in this.def.properties) {
                var prop = this.createProperty(this.def.properties[name]);
                if (prop) this.properties[name] = prop;
            }

            for (var name in this.def.statics) {
                var def = this.def.statics[name];
                var prop = this.createProperty(def);

                if (prop) {
                    if (def.inheritable) prop.inheritable = true;
                    this.statics[name] = prop;
                }
            }

            this.configs = this.def.configs;
        }
    },

    createProperty: function(def) {
        var type, prop = new infer.AVal();

        if (def.kind === 'method') {
            var args = def.params.map(function(param) {return this.createLazyType(param.type)}.bind(this)),
                argNames = def.params.map(function(param) { return param.name }),
                returnType = def.returnType ? this.createLazyType(def.returnType) : infer.ANull;

            type = new infer.Fn(def.name, this.scope, args, argNames, returnType);
            if (def.url) type.url = def.url;

            var returnType = customReturnTypes[this.name + '#' + def.name];
            if (returnType) {
                type.computeRet = returnType;
            }

            this.propagateThis(def);
        } else {
            type = this.createLazyType(def.type);
        }

        type.span = def.span;
        type.origin = def.origin;
        type.url = def.url;

        prop.addType(type);
        prop.declaringClass = this.name;
        prop.sencha = true;
        return prop;
    },

    /**
     * Creates an AVal that looks up prototypes for the specified class name when .types is accessed
     * @param {String} className A fully qualified Ext JS class
     * @returns {infer.Obj/infer.AVal}
     */
    createLazyType: function(className) {

        // note: primitive classes need to be extended because we add origin information for definition lookup in #createProperty
        if (className === 'String') {
            return _.create(this.cx.str);
        } else if (className === 'Number') {
            return _.create(this.cx.num);
        } else if (className === 'Boolean') {
            return _.create(this.cx.bool);
        } else if (className === 'Function') {
            return _.create(this.cx.protos.Function);
        } else if (className === 'Object') {
            return _.create(this.cx.protos.Object);
        } else if (className === 'Array') {
            return _.create(this.cx.protos.Array);
        } else if (className === 'RegExp') {
            return _.create(this.cx.protos.RegExp);
        } else if (className === 'Symbol') {
            return _.create(this.cx.protos.Symbol);
        }

        var type = new infer.AVal();
        if (className) {
            Object.defineProperty(type, 'types', {
                get: function() {
                    return _.flatten(className.split(/\//).map(function(name) {
                        return IndexUtil.findPrototypes(name);
                    }));
                }
            })
        }

        return type;
    },

    /**
     * Adds this type as a constructor in tern's top scope
     * @returns {infer.AVal}
     */
    addToTopScope: function() {
        _.union([this.name], this.def.alternateClassNames || []).forEach(function(name) {
            var parts = name.split(/\./),
                base = this.scope,
                simpleName = parts[parts.length-1];

            for (var i=0; i<parts.length-1; i++) {
                var part = parts[i];
                var aVal = base.props[part];

                // prevent internal Tern indexing from converting an object to a function
                //if (aVal) _.remove(aVal.types, function(t) { return t instanceof infer.Fn && !t.extJSClass });

                if (!aVal) aVal = base.props[part] = new infer.AVal();
                aVal.sencha = true;

                var namespace = _.find(aVal.types, function(type) {
                    return !type.extJSClass;
                });

                if (!namespace) {
                    namespace = new Namespace(part);
                    aVal.addType(namespace);
                }

                base = namespace;
            }

            var result = base.props[simpleName] = (base.props[simpleName] || new infer.AVal());
            result.sencha = true;
            result.addType(this.type);

            // since properties are lazy-loaded, we don't actually need to do a real purge, which takes nearly a minute for the full Ext JS library
            this.type.purge = doNothing;
        }.bind(this));
    },

    addToAliasScope: function() {
        var aliases = this.def.aliases,
            scope = global.tern.aliasScope;

        for (var i=0; i<aliases.length; i++) {
            var parts = aliases[i].split('.');

            for (var j=0; j<parts.length; j++) {
                var ns = scope.defProp(parts[j]),
                    scope = ns.types[0];

                ns.sencha = true;

                if (!scope) {
                    scope = new infer.Obj();
                    ns.addType(scope);
                }
            }
        }
    },

    /**
     * Returns the short form of the specified fully-qualified name
     * @param {String} fqName
     * @returns {String}
     */
    getShortName: function(fqName) {
        var parts = fqName.split(/\./)
        return parts[parts.length-1];
    },

    /**
     * Returns an array of classes and mixins from which the current class inherits
     * @returns {*}
     */
    getSuperClasses: function() {
        var classNames = _.union([], this.def.mixins);
        if (this.def.extend) classNames.push(this.def.extend);
        classNames = _.without(classNames, this.name); // ensure this class does not extend itself
        return _.uniq(classNames);
    },

    /**
     * Indexes the specified node as a class
     */
    index: function() {
        if (this.def.aliases) {
            this.def.aliases.forEach(function(alias) {
                indexes.alias.put(alias, this.name, this.def.origin);
            }.bind(this));
        }
    },

    /**
     * Links the this reference in all methods of the class being parsed.  This makes completion on this._
     * work in methods.
     * @param {Object} def A member definition from extract
     */
    propagateThis: function(def) {
        var node = def._node;
        if (!node) return;
        if (node.type === 'Property') node = node.value;
        if (node && node.scope) this.proto.propagate(node.scope.fnType.self);
    }
};
