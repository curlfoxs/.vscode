"use strict";

var infer = require('../../../lib/infer'),
    indexes = require('./indexes'),
    fs = require('fs'),
    os = require('./../../../lib/os'),
    _ = require('lodash');

/**
 * Checks if a property belongs to an Ext class
 * @param {Node} propertyNode
 * @returns {*|boolean}
 */
function isPropertyOfFrameworkClass(prop) {
    return _.startsWith(prop.declaringClass, 'Ext.');
}

/**
 * Checks if a property belongs to object prototype
 * @param prop
 * @returns {_.propertyOf|*|boolean}
 */
function isPropertyOfExtClass(prop){
    return prop.declaringClass;
}

var IndexUtil = {
    /**
     * Returns all objects in a namespace
     * @param {String} name A fully qualified named (e.g. "MyApp.view.main")
     * @returns {infer.Obj[]}
     */
    findObjects: function(name) {
        if (typeof(name) !== 'string') return []; // this often happens because TypeUtil.typeOf returns implicit types as well as strings

        function doFind(name, scope) {
            if (!scope) return [];

            var parts = name.split(/\./),
                next = parts.shift(),
                results = [];

            if (next) {
                var newScope = scope.props[next];

                if (newScope) for (var i=0; i<newScope.types.length; i++) {
                    results = results.concat(doFind(parts.join('.'), newScope.types[i]));
                }
            } else {
                return [scope];
            }

            return results;
        }

        return doFind(name, infer.cx().topScope);
    },

    /**
     * Returns the visible constructor definitions for a class
     * @param {String} className The name of the class
     * @returns {infer.Fn[]}
     */
    findConstructors: function(className) {
        return _.filter(IndexUtil.findObjects(className), function(constructor) {
            return constructor.extJSClass && constructor.extJSClass.isVisible();
        });
    },

    /**
     * Returns the visible prototypes for a class
     * @param {String} className
     * @returns {infer.Obj[]}
     */
    findPrototypes: function(className) {
        var constructors = this.findConstructors(className),
            prototypes = [];

        for (var i=0; i<constructors.length; i++) {
            var constructor = constructors[i];

            if (constructor instanceof infer.Fn) {
                var proto = constructor.props['prototype'];
                if (proto) prototypes = prototypes.concat(constructor.props['prototype'].types);
            } else if (constructor instanceof infer.Obj) {
                prototypes.push(constructor);
            }
        }

        return prototypes;
    },

    /**
     * Creates an AVal containing all prototypes for the given class name.
     * @param {String...} classNames
     * @returns {exports.AVal}
     */
    createAValForClass: function() {
        var result = new infer.AVal();

        Array.prototype.slice.call(arguments).forEach(function(className) {
            IndexUtil.findPrototypes(className).forEach(function(proto) {
                result.addType(proto);
            });
        });

        return result;
    },

    /**
     * Creates an AVal containing all prototypes with the given alias
     * @param {String...} aliases
     * @returns {infer.AVal}
     */
    createAValForAlias: function() {
        var classNames = {};

        Array.prototype.slice.call(arguments).forEach(function(argument) {
            indexes.alias.get(argument).forEach(function(className) {
                classNames[className] = true;
            });
        });

        return IndexUtil.createAValForClass.apply(this, Object.keys(classNames));
    },

    /**
     * Removes all cached data = require(the origin of the ast
     * @param {AST} ast
     */
    purge: function(origin) {
        for (var i in indexes) {
            if (indexes.hasOwnProperty(i)) {
                indexes[i].purge(origin);
            }
        }
    },

    /**
     * Checks if a property belongs to object prototype
     * @param prop
     * @returns {_.propertyOf|*|boolean}
     */
    isPropertyOfUserClass: function(prop){
        return isPropertyOfExtClass(prop) && !isPropertyOfFrameworkClass(prop);
    }
};

module.exports = IndexUtil;