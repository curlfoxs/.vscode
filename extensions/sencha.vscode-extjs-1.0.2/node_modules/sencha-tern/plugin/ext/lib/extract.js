"use strict";

var parseComments = require('comment-parser');
var _ = require('lodash');
var infer = require('../../../lib/infer');
var ASTUtil = require('./ASTUtil');
var indexes = require('./indexes');
var path = require('path');
var walk = require('./walk');
var toolkitFor = require('./toolkitFor');
var TypeUtil = require('./TypeUtil');
var appFor = require('./appFor');
var createSpan = ASTUtil.createSpan;

/**
 * Extracts all definitions from a source tree
 * @param {Node} ast The root ast to walk
 * @return {Object} A map of class name => definition for all classes defined in the file
 */

module.exports = function extract(ast) {
    indexProperties(ast);
    return new Extractor(ast).defs;
};

/**
 * Creates type definitions for Ext JS classes.  This class should not have any dependencies to tern, only the ast
 * class from acorn - that way it can be pulled out into a seperate package later if we decide to use this as a replacement
 * for jsduck.
 * @param {Object} A map of className => definition to which definitions should be added
 * @param {Node} node The root node to parse
 * @constructor
 */
function Extractor(ast) {
    _.assign(this, {
        defs: {},
        origin: ast.sourceFile.name,

        /**
         * Keep track of comments that have already been processed.  Comments get processed both as comments before
         * and comments within nodes.  When processed as comments before nodes, the generated span is more accurate
         * for definition lookup.
         */
        processedComments: {},

        /**
         * Keep track of the nodes that have been processed
         */
        processedNodes: {},

        /**
         * maintains a stack of states as we walk the AST
         */
        stack: []
    });

    this.def = this.findOrCreateDef(''); // empty class def for members that cannot be tied to a class
    this.state = { def: this.def };

    createBodyForInnerComments(ast);

    walk(ast, this.processNode.bind(this));
}

/**
 * Creates body nodes so that an file with comments at the root (program node) can be processed correctly.  For example,
 * Ext.view.View gets some overrides from such a file in Ext JS 6.0.1:
 * http://docs.sencha.com/extjs/6.0/6.0.1-classic/source/ViewController2.html#Ext-app-ViewController-method-afterRender
 * @param {Node} node Any node
 * @return {Node[]}
 */
function createBodyForInnerComments(node) {
    node.innerComments.forEach(function(comment) {
        node.body.push({
            comments: [comment],
            parent: node,
            sourceFile: node.sourceFile,
            type: 'Identifier'
        });
    });
}

Extractor.prototype = {

    /**
     * Processes any node in the AST
     * @param {Node} node
     * @param {Function} keepGoing
     */
    processNode: function(node, keepGoing) {
        var tags = this.getTags(node.comments), classTag = _.find(tags, function(t) { return t.tag === 'class' });

        this.extractMembersFromComments(node);

        if (TypeUtil.isExtDefine(node)) {
            // Ext.define
            return this.withClassContext(node['arguments'][0] && node['arguments'][0].value, node, tags, function() {
                if (this.def.name !== 'Ext.Base' && !this.def.extend) this.def.extend = 'Ext.Base';
                keepGoing();
            }.bind(this));
        } else if (classTag && classTag.name) {
            // @class
            var className = TypeUtil.isExtApply(node) ? classTag.name + '.overrides' : classTag.name;

            return this.withClassContext(className, node, tags, function () {
                var proto = findPrototype(node.sourceFile.ast, classTag.name);

                if (proto) proto.properties.forEach(function (prop) {
                    this.extractMembersFromComments(prop);
                    this.extractMemberFromProperty(prop);
                }.bind(this));

                keepGoing();
            }.bind(this));
        } else if (node.type === 'AssignmentExpression') {
            var className = ASTUtil.getFullyQualifiedName(node.left);

            if (this.defs[className]) {
                return this.withClassContext(className, node, tags, keepGoing);
            }
        } else if (TypeUtil.isExtApply(node)) {
            var className = ASTUtil.getFullyQualifiedName(node.arguments[0]);

            if (className === 'Ext') {
                return this.withClassContext(className + '.overrides', node, tags, keepGoing);
            }
        } else if (node.type === 'Property') {
            // properties
            if (containsConfigs(node)) {
                return this.withBlockContext(node, keepGoing);
            } else {
                var configObject = node.parent,
                    parentProperty = ASTUtil.getParentOfType(node, 'Property', 2);

                if (configObject === this.state.configObject || (parentProperty && parentProperty.parent === this.state.configObject && containsConfigs(parentProperty))) {
                    this.extractMemberFromProperty(node);
                    return keepGoing();
                }
            }
        }

        keepGoing();
    },

    /**
     * Creates a new class context and calls the callback
     * @param {String} className
     * @param {Object[]} tags
     * @param {Function} callback
     */
    withClassContext: function(className, node, tags, callback) {

        if (_.find(tags, function(t) { return t.tag === 'ignore' })) return;

        if (className) {
            if (!this.state || this.def.name !== className) {
                if (this.state) this.stack.push(this.state);
                this.def = this.findOrCreateDef(className);
                this.def.span = this.def.span || createSpan(node);
                this.state = { def: this.def };
            }

            if (!this.state.configObject && node.type === 'CallExpression') {
                this.state.configObject = node.arguments[1];
            }
        }

        tags.forEach(function(tag) {
            switch(tag.tag) {
                case 'private':
                    this.def.private = true;
                    break;
                case 'alternateClassName':
                    this.def.alternateClassNames.push(tag.name);
                    break;
                case 'mixins':
                    this.def.mixins.push(tag.name);
                    break;
                case 'extends':
                case 'extend':
                    this.def.extend = tag.name;
                    break;
                case 'singleton':
                    this.def.singleton = true;
                    break;
            }
        }.bind(this));

        callback();
    },

    /**
     * Sets the following properties based on the name of the block:
     *
     *  static
     *  inheritable
     *  private
     *
     * @param {Node} propNode A node of type "Property"
     * @returns {Boolean}
     */
    withBlockContext: function(propNode, callback) {
        if (this.state) this.stack.push(this.state);

        var name = propNode.keyName;

        this.state = _.create(this.state, {
            "static": staticBlockNames.indexOf(name) !== -1 ? propNode.value : null,
            "private": name === 'privates',
            inheritable: name === 'inheritableStatics',
            eventedConfig: name === 'eventedConfig',
            configBlock: name.match(/config$/i)
        });

        callback();

        this.state = this.stack.pop();
    },

    /**
     * Returns the def for the specified class, creates one if it doesn't already exist
     * @param {String} className The name of the class
     * @param {Object} [defaults] Default properties to assign to the newly created def
     * @returns {Object}
     */
    findOrCreateDef: function(className) {
        this.createUrl = function(options) {
            return _.assign({ className: className.replace(/\.overrides$/, '') }, options);
        };

        var def = this.defs[className];

        if (!def) {
            def = {
                name: className.replace('.overrides', ''),
                mixins: [],
                alternateClassNames: [],
                origin: path.resolve(this.origin),
                configs: {},
                hideConfigs: [],
                properties: {},
                statics: {},
                events: {},
                aliases: [],
                boundValues: {},
                toolkit: toolkitFor(this.origin),
                url: this.createUrl(),
                override: _.endsWith(className, '.overrides')
            };

            if (className.length) this.defs[className] = def;
        }

        return def;
    },

    /**
     * Creates a member definition from a property node
     * @param {Property} propNode
     */
    extractMemberFromProperty: function(propNode) {
        var name = propNode.keyName,
            handler = specialPropertyHandlers[name];

        if (!handler || handler.call(this, propNode) !== false) {
            var jsDuckComments = _.filter(propNode.comments || [], isDocComment),
                tags = this.getTags(jsDuckComments),
                type = inferType(tags, propNode);

            if (this.state.configBlock) this.addAccessors(name, type, propNode, tags);

            if (this.skip(jsDuckComments, tags, false, name)) return; // don't create property data for undocumented framework properties

            var tag = findMatchingMemberTag(tags, name);

            if (this.state.configBlock || (tag && tag.tag === 'cfg') || _.find(tags, function(t) { return t.tag === 'template' })) {
                this.addConfig(name, type, propNode, tags);
            } else {
                this.addProperty({name: name, node: propNode.value, type: type, tags: tags});
            }
        }
    },

    /**
     * Creates a config, getter, and setter
     * @param {String} name
     * @param {String} type
     * @param {Object} node
     * @param {Object[]} tags
     * @param {String} [access]
     * @return {Object} the added config definition
     */
    addConfig: function(name, type, node, tags, access) {
        var classDef = this.getClassDefFor(node, tags);

        if (containsTag(tags, 'hide')) {
            classDef.hideConfigs.push(name);
        } else {
            var tagPresence = {};
            for (var i=0; i<tags.length; i++) tagPresence[tags[i].tag] = true;

            var def = {
                name: name,
                type: type,
                origin: this.origin,
                span: createSpan(node),
                _node: node,
                access: tagPresence['protected'] ? 'protected' : tagPresence['private'] ? 'private' : access || 'public',
                url: this.createUrl({type: 'cfg', isStatic: false, name: name})
            };

            if (node && node.value && node.value.type === 'Literal') {
                def.defaultValue = node.value.value;
            }

            if (tagPresence['accessor']) this.addAccessors(name, type, node, tags);

            classDef.configs[name] = def;

            if (this.state.eventedConfig || tagPresence.evented) {
                var eventName = name.toLowerCase() + 'change';

                this.def.events[eventName] = {
                    name: eventName,
                    params: [{
                        name: 'cmp',
                        type: this.name
                    }, {
                        name: 'value',
                        type: type
                    }, {
                        name: 'oldValue',
                        type: type
                    }, {
                        name: 'eOpts',
                        type: 'Object'
                    }]
                }
            }

            return def;
        }
    },

    /**
     * Adds getter and setter methods for a property in a config block
     * @param name
     * @param type
     * @param node
     * @param tags
     */
    addAccessors: function(name, type, node, tags) {
        var capName = _.capitalize(name);

        this.def.properties['get' + capName] = {
            kind: 'method',
            origin: this.origin,
            span: createSpan(node),
            params: [],
            returnType: type,
        };

        this.def.properties['set' + capName] = {
            kind: 'method',
            origin: this.origin,
            span: createSpan(node),
            params: [{ name: name, type: type }],
        };

        var evented = this.state.eventedConfig;
        this.state.eventedConfig = false;
        this.addConfig('apply' + capName, "Function", node, [], "protected");
        this.addConfig('update' + capName, "Function", node, [], "protected");
        this.state.eventedConfig = evented;
    },

    /**
     * Extracts members from jsduck comments which may or may not be attached to properties
     * @param {Node} node The node to process
     */
    extractMembersFromComments: function(node) {
        this.currentNode = node;

        if (node.comments) node.comments.forEach(function(comment) {
            if (isDocComment(comment)) this.addFromComment(comment, node);
        }.bind(this));

        if (node.innerComments) node.innerComments.forEach(function(comment) {
            if (isDocComment(comment)) this.addFromComment(comment);
        }.bind(this));

        delete this.currentNode;
    },

    /**
     * Creates a class member definition from a jsduck comment
     * @param {String} comment The comment text
     * @param {String} node The node to which the comment is attached.
     * @private
     */
    addFromComment: function(comment, node) {
        var tags = this.getTags(comment),
            tag = _.find(tags, function(t) { return MEMBER_TAGS.indexOf(t.tag) !== -1 }),
            def;

        if (this.skip([comment.text], tags)) return; // don't create properties for Ext's @private or @protected members

        var name = (tag && tag.name) || getNameOfNode(node) || getNameFromInheritDoc(tags);
        if (!name) return;

        if (tag) {
            switch(tag.tag) {
                case 'cfg':
                    def = this.addConfig(name, tag.type, node, tags);
                    break;
                case 'property':
                    def = this.addProperty({ name: name, tags: tags, type: tag.type, node: node });
                    break;
                case 'method':
                    def = this.addMethod(name, tags, node);
                    break;
                case 'event':
                    def = this.addEvent(name, tags, node);
            }
        } else if (isProbablyMethod(node, tags)) {
            def = this.addMethod(name, tags, node)
        } else if (!_.find(tags, function(t) { return t.tag === 'class' })) {
            def = this.addProperty({ name: name, tags: tags, type: 'property', node: node });
        }

        if (def && !def.span) def.span = createSpan(comment);
    },

    /**
     * Adds data from comment tags to the specified definition
     * @param {Object} def
     * @param {Object[]} tags
     */
    addMetaDataFromComment: function(def, tags) {
        tags.forEach(function(tag) {
            var handler = tagHandlers[tag.tag];
            if (handler) handler(def, tag);
        });
    },

    /**
     * Adds an object representing a property or method
     * @param {Object} options
     * @param {String} options.name The name of the property
     * @param {Node} options.node The ast node in which the property is declared
     * @param {Array} options.tags An array of JSDuck tags
     * @param {String} options.type The fully qualified class name
     */
    addProperty: function(options) {
        var name = options.name,
            node = options.node,
            tags = options.tags || [],
            type = options.type;

        if (node && node.type === 'FunctionExpression') {
            return this.addMethod(name, tags, node);
        } else {
            return this.addDef(node, tags, { name: name, kind: 'property', type: type });
        }
    },

    /**
     * Adds an object representing a method
     * @param {String} name
     * @param {Tag[]} tags
     * @param {Node} node
     */
    addMethod: function(name, tags, node) {
        tags = tags || [];

        var params;

        if (node && node.type === 'FunctionExpression') {
            // create function from FunctionExpression
            var paramTags = this.extractParams(tags);
            params = node.params.map(function(param) {
                var tag = paramTags[param.name];
                return {
                    name: param.name,
                    type: tag ? tag.type : undefined
                }
            });
        } else {
            // create function from comment only
            params = [];
            tags.forEach(function(tag) {
                if (tag.tag === 'param') {
                    params.push({
                        name: tag.name || '?',
                        type: tag.type
                    })
                }
            })
        }

        var returnTag = _.find(tags, function(tag) { return tag.tag.match(/^returns?$/) });

        return this.addDef(node, tags, {
            kind: 'method',
            name: name,
            params: params,
            _node: node,
            returnType: returnTag && returnTag.type,
        });
    },

    /**
     * Returns true if the specified node has a @static tag in the comments or is in a static config block
     * @param {Node} node
     * @param {Object[]} tags
     * @returns {Boolean}
     */
    isStatic: function(node, tags) {
        // handle assignments to classes as in Ext.Factory#define
        if (node && node.type === 'AssignmentExpression' && node.left && node.left.object && this.defs[ASTUtil.getFullyQualifiedName(node.left.object) + '.overrides']) {
            return true;
        }

        var parentProperty = node ? node.parent.parent : null;

        while (parentProperty && parentProperty.type !== 'Property') {
            parentProperty = parentProperty.parent;
        }

        if (_.find(tags, function (t) { return t.tag === 'static'; })) return true;

        return this.state.static && this.state.static === ASTUtil.getParentOfType(node, 'ObjectExpression');
    },

    /**
     * Adds a member definition to the appropriate class and collection
     * @param {Node} node
     * @param {Object[]} tags
     * @param {Object} def
     */
    addDef: function(node, tags, def) {
        var classDef = this.getClassDefFor(node, tags),
            collection = this.isStatic(node, tags) ? 'statics' : 'properties';

        _.assign(def, {
            inheritable: this.state.inheritable,
            origin: this.origin,
            span: createSpan(node || this.currentNode),
            url: this.createUrl({type: def.kind, isStatic: collection === 'statics', name: def.name})
        });

        if (this.state.isPrivate) def.private = true;
        this.addMetaDataFromComment(def, tags);

        var existing = classDef[collection][def.name];

        if (existing) {
            _.defaults(existing, def); // don't overwrite data from the first pass, which uses the property and is generally more accurate
        } else {
            classDef[collection][def.name] = def;
        }

        return def;
    },

    /**
     * Retreives the definition corresponding to the class referenced in the member tag if present, otherwise the class referenced by this.name
     * @param {Node} node
     * @param {Object[]} tags
     * @returns {Object}
     */
    getClassDefFor: function(node, tags) {
        var memberTagValue = getMemberTagValue(tags);

        if (memberTagValue) {
            return this.findOrCreateDef(memberTagValue + '.overrides');
        } else if (node && node.type === 'AssignmentExpression') {
            var className = ASTUtil.getFullyQualifiedName(node.left.object);
            if (className && className.match(/^[A-Z]/)) return this.findOrCreateDef(className + '.overrides');
        }

        return this.def;
    },

    /**
     * Creates an object representing an event
     * @param {String} name
     * @param {Object[]} tags
     * @param {Node} node
     * @returns {Object} The added definition object
     */
    addEvent: function(name, tags, node) {
        var event = {
            name: name,
            params: [],
            origin: this.origin,
            span: createSpan(node),
            url: this.createUrl({type: 'event', name: name})
        };

        tags.forEach(function(tag) {
            if (tag.tag === 'param' && tag.name) {
                event.params.push({name: tag.name, type: tag.type});
            }
        }.bind(this));

        return this.getClassDefFor(node, tags).events[name] = event;
    },

    /**
     * Returns true if this is a Ext framework class and no comments are provided or a @private or @protected tag is present
     * @param {String[]} jsDuckComments
     * @param {Object[]} tags
     * @param {Boolean} requireComment
     * @return {Boolean}
     */
    skip: function(jsDuckComments, tags, requireComment, memberName) {
        var tagPresence = {};

        for (var i=0; i<tags.length; i++) tagPresence[tags[i].tag] = true;

        // do not create properties for framework members without jsduck comments, private, or protected members
        if (this.def.name.indexOf('Ext.') === 0) {
            requireComment = true;

            if (jsDuckComments.length === 0 || ((tagPresence['protected'] || tagPresence['private']) && !tagPresence['template'])) {
                return true;
            }
        }

        if (_.find(tags, function(t) { return SKIP_TAGS.indexOf(t.tag) !== -1 })) {
            return true;
        } else if (!requireComment) {
            return false;
        } else if (jsDuckComments.length === 0) {
            return true;
        } else if (memberName) {
            var memberTag = _.find(tags, function(t) { return MEMBER_TAGS.indexOf(t.tag) !== -1 })
            return memberTag && memberTag.name !== memberName;
        }
    },

    /**
     * Extracts the names of mixin classes from an object or array expression.
     * @param {Node} node
     */
    addMixins: function(node) {
        var mixins = this.def.mixins;

        if (node.type === 'ArrayExpression') {
            node.elements.forEach(function(el) { mixins.push(el.value) });
        } else if (node.type === 'ObjectExpression') {
            node.properties.forEach(function(property) { mixins.push(property.value.value) });
        }
    },

    /**
     * @param {Object} comment
     * @returns {*}
     * @private
     */
    getTags: function(comment) {
        if (_.isArray(comment)) {
            // previous comments may declare other properties and should be excluded.
            comment = getLastDocComment(comment)
        }

        if (!comment) return [];

        if (!isDocComment(comment)) return []; // not a jsdoc comment, skip parsing, which is expensive
        var parsed = parseComments('/*' + comment.text + '*/')[0];
        var tags = parsed ? parsed.tags : [];

        tags.forEach(function(tag) {
            if (tag.name) {
                // if a tag does not have a name, the comment parser will erroneously use the text from the next line
                // as the name, so we fix that here
                tag.name = tag.name.match(/^\n/) ? undefined : tag.name;
            }
        });

        return tags;
    },

    /**
     * @param comments
     * @returns {Object} A map of param name to param tag
     * @private
     */
    extractParams: function(tags) {
        var map = {};

        tags.forEach(function(tag) {
            if (tag.tag === 'param' && tag.name) {
                map[tag.name] = tag;
            }
        });

        return map;
    }
}; // end Extractor

/**
 * The tags which determine the type of a property
 */
var MEMBER_TAGS = ['cfg', 'method', 'property', 'event'];

/**
 * A map of lower-case Ext JS types to TernJS types
 */
var PRIMITIVE_TYPES = {
    integer: 'num',
    number: 'num',
    string: 'str',
    boolean: 'bool'
};

/**
 * Members are skipped when these jsduck tags are present
 */
var SKIP_TAGS = ['deprecated', 'removed', 'ignore'];
var INDEX_USAGE_PROPERTIES = ['xtype', 'xclass', 'reference', 'controller'];

/**
 * Returns true if the node's value should be added to the usage index
 * @param {Node} node The node to index
 * @param {String} property The name of the property whose value is the node
 * @returns {boolean}
 */
function shouldIndexUsage(node, property) {
    if (typeof(node.value) !== 'string') {
        return false;
    } else if (INDEX_USAGE_PROPERTIES.indexOf(property) !== -1) {
        return true;
    } else if (TypeUtil.createsInstance(node.parent)) {
        return true;
    }
}

/**
 * Names of blocks whose that define static members
 */
var staticBlockNames = ['statics', 'inheritableStatics'];
var configBlockNames = ['config', 'cachedConfig', 'platformConfig', 'eventedConfig', 'responsiveConfig', 'beforeRenderConfig'];

/**
 * Returns true if the specified property contains configs for the class definition
 * @param {Node} propNode A node of type="Property"
 * @return {Boolean}
 */
function containsConfigs(propNode) {
    if (!propNode) return false;

    var name = propNode.keyName, value = propNode.value;

    return name && value && value.type === 'ObjectExpression' && (
            _.union(staticBlockNames, ['privates']).indexOf(name) !== -1 ||
            configBlockNames.indexOf(name) !== -1
        );
}

/**
 * Returns true if the array contains a tag with the specified name
 * @param tags The array
 * @param tag The name of the tag to search for
 * @returns {*}
 */
function containsTag(tags, tag) {
    return _.find(tags, function(t) { return t.tag === tag });
}

/**
 * Gets the value of the @member tag if one exists
 * @param {Object[]} tags
 * @returns {String}
 */
function getMemberTagValue(tags) {
    var memberTag = _.find(tags, function(t) { return t.tag === 'member' });
    return memberTag ? memberTag.name.replace(/\.$/, '') : undefined; // replace trailing "." - this shows up sometimes in the Ext JS source - see SpreadsheetModel.js, event beforeselectionextend
}

/**
 * Finds the @cfg, @property, @method, or @event tag with the specified name or any of those without a name
 * @param tags
 * @param name
 */
function findMatchingMemberTag(tags, name) {
    return _.find(tags, function(tag) { return MEMBER_TAGS.indexOf(tag.tag) !== -1 && (!tag.name || tag.name === name) });
}

/**
 * Returns the name of the property if the node is a property
 * @param {Node} node
 * @returns {String}
 */
function getNameOfNode(node) {
    if (!node) return;

    switch (node.type) {
        case 'Property':
            return node.keyName;
        case 'AssignmentExpression':
            return node.left.property && node.left.property.name;
    }
}

/**
 * Returns the type of node being assigned
 * @param node
 * @returns {String}
 */
function getTypeOfValue(node) {
    if (!node) return;

    switch (node.type) {
        case 'Property':
            if (node.value) {
                if (node.value.type === 'ConditionalExpression') {
                    if (node.value.consequent.type === 'FunctionExpression' || node.value.alternate.type === 'FunctionExpression') {
                        return 'FunctionExpression';
                    } else {
                        return node.value.alternate.type;
                    }
                } else {
                    return node.value.type;
                }
            }
        case 'AssignmentExpression':
            return node.right.type;

    }
}

/**
 * Returns the type declared in the tag if present, otherwise tries to infer the type from the node's value
 * @param {Object[]} tags
 * @param {Node} propertyNode A node of type "Property"
 * @returns {*}
 */
function inferType(tags, propertyNode) {
    var tag = _.find(tags, function(tag) { return ['cfg', 'method', 'property'].indexOf(tag.tag) !== -1 });

    if (tag && tag.type) {
        return tag.type;
    } else if (propertyNode.value) {
        if (propertyNode.value.type === 'FunctionExpression') {
            return 'Function'
        } else if (propertyNode.value.hasOwnProperty('value')) {
            return _.capitalize(typeof(propertyNode.value.value));
        }
    }
}

/**
 * Finds the object assigned to the prototype matching name
 * @param {Node} ast The ast to search
 * @param {String} name The name of the prototype to find
 * @returns {Node} of type ObjectExpression
 */
function findPrototype(ast, name) {
    var result;

    walk(ast, function(node, keepGoing) {
        if (node.type === 'AssignmentExpression' &&
            name + '.prototype' === ASTUtil.getFullyQualifiedName(node.left) &&
            node.right.type === 'ObjectExpression'
        ) {
            result = node.right;
            return;
        }

        keepGoing();
    });

    return result;
}

/**
 * Returns true if the node is a call expression calling the specified method on the specified class
 * @param {Node} node
 * @param {String} cls The class name
 * @param {String} method The method name
 * @returns {Boolean}
 */
function isCallTo(node, cls, method) {
    return node && node.type === 'CallExpression' &&
        node.callee.object &&
        node.callee.object.name === cls &&
        node.callee.property.name == method;
}

/**
 * Returns true if the node is a property with a function for a value or has @param or @return tags.
 * Always returns false if a @class tag is found.
 * @param {Node} node
 * @param {Object[]} tags
 * @returns {Boolean}
 */
function isProbablyMethod(node, tags) {
    if (_.find(tags, function(t) { return t.tag === 'class'})) return false;
    return 'FunctionExpression' === getTypeOfValue(node) || _.find(tags, function(t) { return t.tag === 'param' || t.tag === 'return'});
}

/**
 * Returns the property name on the inheritdoc tag if one exists
 * @param tags
 * @returns {*}
 */
function getNameFromInheritDoc(tags) {
    for (var i=0; i<tags.length; i++) {
        var tag = tags[i];

        if (tag.tag === 'inheritdoc') {
            var name = tag.name && tag.name.split('#');

            if (name) {
                if (name.length === 2) {
                    return name[1];
                } else if (name.length === 1) {
                    return name[0];
                }
            }
        }
    }
}

/**
 * Returns true if the specified comment starts with /**
 * @param {Object} c
 * @returns {boolean}
 */
function isDocComment(c) {
    return c && c.text && c.text.indexOf('*') === 0;
}

/**
 * Returns the last comment in the array which is a doc comment
 * @param {Object[]} comments
 * @returns {Object}
 */
function getLastDocComment(comments) {
    if (!comments) return undefined;

    for (var i=comments.length - 1; i>=0; i--) {
        var comment = comments[i];
        if (isDocComment(comment)) return comment;
    }
}

/**
 * Specific handlers for different config properties
 */
var specialPropertyHandlers = {
    extend: function(propNode) {
        if (propNode.value.value) this.def.extend = propNode.value.value;
        return false;
    },
    mixins: function(propNode) {
        this.addMixins(propNode.value);
        return false;
    },
    xtype: function(propNode) {
        this.def.aliases = [];
        ASTUtil.getLiteralValues(propNode.value).forEach(function(xtype) {
            if (xtype.match(/\S+/)) this.def.aliases.push('widget.' + xtype);
        }.bind(this));
        return false;
    },
    alias: function(propNode) {
        this.def.aliases = [];
        ASTUtil.getLiteralValues(propNode.value).forEach(function(alias) {
            if (alias.match(/\S+/)) this.def.aliases.push(alias);
        }.bind(this));
        return false;
    },
    alternateClassName: function(propNode) {
        this.def.alternateClassNames = ASTUtil.getLiteralValues(propNode.value);
        return false;
    },
    override: function(propNode) {
        if (propNode.value && propNode.value.type == 'Literal') {
            this.def.name = propNode.value.value;
            this.def.override = true;
        }
        return false;
    },
    singleton: function(propNode) {
        this.def.singleton = propNode.value.value === true
        return false;
    },
    links: function(propNode) {
        if (propNode.value && propNode.value.type === 'ObjectExpression') {
            for (var i=0; i<propNode.value.properties.length; i++) {
                var config = propNode.value.properties[i];
                this.def.boundValues[config.keyName] = {
                    name: config.keyName,
                    type: ASTUtil.findPropertyValue(config.value, 'type') || 'Ext.data.Model',
                    origin: this.origin,
                    span: createSpan(config)
                };
            }
        }
    },
    data: function(propNode) {
        if (propNode.value && propNode.value.type === 'ObjectExpression') {
            for (var i=0; i<propNode.value.properties.length; i++) {
                var config = propNode.value.properties[i];
                this.def.boundValues[config.keyName] = {
                    name: config.keyName,
                    origin: this.origin,
                    span: createSpan(config)
                };
            }
        }
    },
    formulas: function(propNode) {
        if (propNode.value && propNode.value.type === 'ObjectExpression') {
            for (var i=0; i<propNode.value.properties.length; i++) {
                var config = propNode.value.properties[i];
                this.def.boundValues[config.keyName] = {
                    name: config.keyName,
                    origin: this.origin,
                    span: createSpan(config)
                };
            }
        }
    },
    stores: function(propNode) {
        if (propNode.value && propNode.value.type === 'ObjectExpression') {
            for (var i=0; i<propNode.value.properties.length; i++) {
                var config = propNode.value.properties[i];
                this.def.boundValues[config.keyName] = {
                    name: config.keyName,
                    type: ASTUtil.findPropertyValue(config.value, 'type') || 'Ext.data.Store',
                    origin: this.origin,
                    span: createSpan(config)
                };
            }
        }
    },
    fields: function(propNode) {
        if (propNode.value && propNode.value.type === 'ArrayExpression') {
            for (var i=0; i<propNode.value.elements.length; i++) {
                var item = propNode.value.elements[i];

                switch (item.type) {
                    case 'Literal':
                        this.def.boundValues[item.value] = { name: item.value, origin: propNode.sourceFile.name, span: createSpan(item) };
                        break;
                    case 'ObjectExpression':
                        var name = ASTUtil.findPropertyValue(item, 'name');
                        if (name) this.def.boundValues[name] = { name: name, type: ASTUtil.findPropertyValue(item, 'type'), origin: propNode.sourceFile.name, span: createSpan(item) };
                }
            }
        }
    },
    schema: function(propNode) {
        if (propNode.value && propNode.value.type === 'ObjectExpression') {
            this.def.namespace = ASTUtil.findPropertyValue(propNode.value, 'namespace');
        }
    },
    storeId: function(propNode) {
        if (propNode.value.type === 'Literal') this.def.storeId = propNode.value.value;
    }
};

/**
 * Functions to call when specific jsduck tags are encountered
 */
var tagHandlers = {
    inheritable: function(def, tag) {
        def.inheritable = true;
    },
    "private": function(def, tag) {
        def.private = true;
    },
    "protected": function(def, tag) {
        def.protected = true;
    }
};

/**
 * Indexes string literals
 * @param {Node} ast An AST node to parse
 */
function indexProperties(ast) {
    var file = ast.sourceFile.name;

    walk(ast, function(node, keepGoing) {
        // index string literals
        if (node.type === 'Literal') {
            var property = node.parent.key ? node.parent.keyName : null;
            if (property === 'type') property = ASTUtil.getParentPropertyName(node.parent);
            if (shouldIndexUsage(node, property)) {
                indexes.usage.put(node.value, { name: node.value, offset: node.end, file: file, property: property, span: ASTUtil.createSpan(node) }, file, node.end);
            }
        } else if (node.type === 'Property' && node.key && node.keyName === 'storeId' && node.value && node.value.type === 'Literal' && typeof(node.value.value) === 'string') {
            var storeId = node.value.value;
            indexes.store.put(storeId, { name: storeId, span: ASTUtil.createSpan(node.value), file: file }, file, node.value.end);
        } else if (node.type === 'Property' && node.key && node.keyName === 'stores' && node.value && node.value.type === 'ArrayExpression') {
            // the stores property of applications and controllers will instantiate stores by looking up a store class by it's short name
            // if the store class does not declare a storeId config, the short name will be used as the storeId
            node.value.elements.forEach(function(literal) {
                if (literal.type === 'Literal' && typeof(literal.value) === 'string') {
                    var storeId = literal.value;
                    indexes.store.put(storeId, { name: storeId, span: ASTUtil.createSpan(literal), file: file, implicit: true }, file, literal.end);
                }
            })
        }

        keepGoing();
    });
}