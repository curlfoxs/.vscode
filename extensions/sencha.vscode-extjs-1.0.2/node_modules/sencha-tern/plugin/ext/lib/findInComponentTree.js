"use strict";

var ASTUtil = require('./ASTUtil'),
    TypeUtil = require('./TypeUtil'),
    IndexUtil = require('./IndexUtil'),
    indexes = require('./indexes'),
    _ = require('lodash'),
    infer = require('../../../lib/infer');

/**
 * Returns the values for the specified property by searching parent components and classes.  For example, use this method to find
 * the bound controller for any node in the component hierarchy.
 * @param {Node} node The node to search
 * @param {String} propertyName The property whose values should be returned
 * @returns {String[]}
 */
module.exports = function findInComponentTree(node, propertyName) {
    if (!node) return [];
    var propNodes = new Finder(propertyName).find(node);
    return _.without(propNodes.map(ASTUtil.getValueOrType), undefined, null);
};

/**
 * @param {String} propertyName The property to search for
 * @constructor
 */
function Finder(propertyName) {
    this.propertyName = propertyName;
    this.processed = {};
}

Finder.prototype = {

    /**
     * Returns true if the node has already been processed.
     * @param {Node} node
     * @returns {boolean}
     */
    hasBeenProcessed: function(node) {
        var key = node.sourceFile.name + ':' + node.start + ':' + node.end;

        if (this.processed[key]) {
            return true;
        } else {
            this.processed[key] = true;
            return false;
        }
    },

    /**
     * Finds the value nodes corresponding to this.propertyName in the component tree and parent classes
     * @param {Node} node An ast node to search
     * @returns {Expression[]} value nodes for the specified property
     */
    find: function(node) {
        if (node && node.type !== 'ObjectExpression') node = ASTUtil.getParentOfType(node, 'ObjectExpression');
        if (!node || this.hasBeenProcessed(node)) return [];

        var propNodes = [],
            propNode = ASTUtil.findProperty(node, this.propertyName);

        if (propNode) {
            propNodes.push(propNode);
        } else {
            // look in class hierarchy
            TypeUtil.typesOf(node).forEach(function(cls) {
                propNodes = propNodes.concat(this.findInClassHierarchy(cls));
            }.bind(this));

            if (TypeUtil.isExtDefine(node.parent)) {
                // look in containers
                this.findContainers(node).forEach(function(container) {
                    propNodes = propNodes.concat(this.find(container));
                }.bind(this));
            } else {
                // look in parent object literal
                propNodes = propNodes.concat(this.find(node.parent));
            }
        }

        return propNodes;
    },

    /**
     * Finds the target property by searching the class hierarchy
     * @param className
     * @returns {Object[]}
     */
    findInClassHierarchy: function(className) {
        var nodes = [];

        IndexUtil.findPrototypes(className).forEach(function(proto) {
            if (proto.extJSClass) {
                var config = proto.extJSClass.getConfigs()[this.propertyName];

                if (config && config.defaultValue) {
                    nodes.push({ value: config.defaultValue });
                }
            }
        }.bind(this));

        return nodes;
    },

    /**
     * If the item is a class definition, returns all containers holding instances of that class, otherwise if the
     * item is an instance (such as Ext.create or an object literal with an xtype), returns the parent container
     * @param itemNode An ASTNode (typically an object literal or call expression)
     * @returns {Node[]} nodes of type ObjectExpression
     */
    findContainers: function(itemNode) {
        var containers = [];

        TypeUtil.typesOf(itemNode).forEach(function(className) {
            var aliases = [className];

            IndexUtil.findConstructors(className).forEach(function(c) {
                // don't need to look into framework classes, only user classes
                if (c.name.indexOf('Ext.') !== 0) aliases = aliases.concat(c.extJSClass.def.aliases.map(function(alias) {
                    return alias.replace(/^[^\.]+\./, ''); // remove prefix
                }));
            });

            aliases.forEach(function(alias) {
                indexes.usage.get(alias).forEach(function(usage) {
                    var element = ASTUtil.parse(usage.file, usage.offset),
                        obj = element && ASTUtil.getParentOfType(element, 'ObjectExpression');

                    if (obj) containers.push(obj);
                });
            })
        });

        return containers;
    }
};