"use strict";

var TypeUtil = require('../TypeUtil'),
    findInComponentTree = require('../findInComponentTree'),
    infer = require('../../../../lib/infer'),
    IndexUtil = require('../IndexUtil'),
    indexes = require('../indexes'),
    ASTUtil = require('../ASTUtil'),
    _ = require('lodash');

var partialExpressionRegex = /\{[^}]*$/,
    fullExpressionRegex = /\{[^}]*}/;

/**
 * Creates a reference to a view model bind expression
 * @param {Node} node The literal node containing the bind expression
 * @param {Integer} [pos] The cursor position.  Leave blank to evaluate the entire expression.
 * @constructor
 */
function BindExpressionReference(node, pos) {
    this.node = node;
    this.pos = pos;
}

BindExpressionReference.prototype = {
    /**
     * Returns an object representing the bound values at the cursor position.
     * example: {theUser.email}
     * @returns {Object}
     */
    getCompletions: function() {
        var tokens = tokenize(this.node, this.pos, true);

        if (tokens) {
            var scope = evaluate(tokens, getViewModelScope(this.node)),
                boundValues = {};

            scope.types.forEach(function(type) {
                if (type.extJSClass && type.extJSClass.def.boundValues) {
                    _.assign(boundValues, type.extJSClass.def.boundValues);
                }
            });

            var completions = _.values(boundValues);

            for (var i=0; i<completions.length; i++) completions[i].reference='BindExpression';

            return completions;
        }
    },

    /**
     * Looks up the definition of the member at the cursor position
     * @returns {infer.AVal}
     */
    findDef: function() {
        var end = this.pos === undefined ? undefined : ASTUtil.findWordEnd(this.node, this.pos);
        var tokens = tokenize(this.node, end, false);
        return tokens && evaluate(tokens, getViewModelScope(this.node));
    }
};

/**
 * Returns true if the specified node contains a bind expression
 * @param {Node} literal A literal node
 * @param {Integer} pos The cursor position
 * @returns {Boolean}
 */
BindExpressionReference.isBindExpression = function(literal, pos) {
    return findExpressions(literal, pos) != null;
};

/**
 * Finds a bind expression in the specified literal up to the given position
 * @param {Node} literal The listeral node containing the expression
 * @param {Integer} pos The cursor position
 * @returns {String[]}
 */
function findExpressions(literal, pos) {
    if (pos === undefined) {
        return literal.value.match(fullExpressionRegex);
    } else {
        var text = literal.sourceFile.text.slice(literal.start+1, pos);
        return text.match(partialExpressionRegex);
    }
}

/**
 * Returns the tokens in the expression as an array
 * @param {Node} literal
 * @param {Integer} pos
 * @param {Boolean} removeLast True to remove the last token, false to include it
 * @returns {String[]}
 */
function tokenize(literal, pos, removeLast) {
    var matches = findExpressions(literal, pos),
        expression = matches && matches[0].replace(/[{}]/g, '');

    if (expression !== null) {
        var tokens = _.trim(expression).split('.');
        if (removeLast) tokens.pop();
        return tokens;
    }
}

/**
 * Evaluates the chain of tokens in the given scope
 * @param {String[]} tokens
 * @param {Object} scope
 * @returns {infer.AVal}
 */
function evaluate(tokens, scope) {
    if (tokens.length === 0) {
        return scope;
    } else {
        var last = tokens.pop(),
            result = new infer.AVal();

        scope = evaluate(tokens, scope);

        if (scope && scope.types) {
            scope.types.forEach(function(type) {
                var value = type.extJSClass.def.boundValues[last];

                if (value) {
                    var protos = value.type && IndexUtil.findPrototypes(value.type);

                    if (protos && protos.length > 0) {
                        protos.forEach(function(proto) {
                            result.addType(_.create(proto, {
                                origin: value.origin,
                                span: value.span
                            }));
                        });
                    } else {
                        result.addType(createAValFor(value));
                    }
                }
            });
        }

        return result;
    }
}

/**
 * Creates an aval for a bound value.  This allows TypeUtil.typeOf to trace back to the bound value's definition.
 * @param {Object} boundValue
 * @returns {exports.AVal}
 */
function createAValFor(boundValue) {
    var aval = new infer.AVal();
    aval.origin = boundValue.origin;
    aval.span = boundValue.span;
    return aval;
}

/**
 * Gets an AVal representing the ViewModel bound to the specified node
 * @param {Node} node An AST node
 * @returns {infer.AVal}
 */
function getViewModelScope(node) {
    var alias = findInComponentTree(node, 'viewModel');
    return alias ? IndexUtil.createAValForAlias('viewmodel.' + alias) : new infer.AVal();
}

module.exports = BindExpressionReference;

