"use strict";

var TypeUtil = require('../TypeUtil'),
    _ = require('lodash'),
    infer = require('../../../../lib/infer'),
    BindExpression = require('./BindExpression'),
    MVC = require('./MVC'),
    ASTUtil = require('../ASTUtil'),
    cmdAutoDependencies = require('../cmdAutoDependencies'),
    walk = require('../walk'),
    Alias = require('./Alias'),
    Store = require('./Store');

function Field(node) {
    this.node = node;
}

Field.prototype = {

    /**
     * Returns all available events
     * @returns {Object[]}
     */
    getCompletions: function() {
        var names = [];

        this.getFields().forEach(function(node) {
            var name, type;

            if (node.type === 'Literal') {
                name = node.value;
            } else {
                name = ASTUtil.findPropertyValue(node, 'name');
                type = ASTUtil.findPropertyValue(node, 'type');
            }

            if (name) names.push({ name: name, type: type, origin: node.origin, span: node.span, reference: 'Field' });
        });

        return names;
    },

    /**
     * Returns field config nodes for the bound store
     * @returns {Node[]} An array of ObjectExpressions
     */
    getFields: function() {
        var store = getBoundStore(this.node),
            fields = [];

        var gatherFields = function(type) {
            var node = ASTUtil.parse(type.origin, type.span);
            if (!node) return;
            var configs = getConfigs(node);

            if (configs.fields && configs.fields.type === 'ArrayExpression') {
                this.modelOrigin = type.origin;
                fields = fields.concat(configs.fields.elements);
            } else if (configs.model && configs.model.type === 'Literal') {
                var model = new MVC(configs.model, cmdAutoDependencies.model).findDef();

                if (model) {
                    this.modelOrigin = model.origin;
                    var classNode = ASTUtil.parse(model.origin, model.span);

                    if (classNode) walk(classNode, function(node, c) {
                        if (node.type === 'Property' && node.key && node.key.name === 'fields' && node.value && node.value.type === 'ArrayExpression') {
                            fields = fields.concat(node.value.elements);
                        }
                        c();
                    })
                }
            }
        }.bind(this);

        if (store) {
            if (store.origin && store.span) gatherFields(store);
            if (store.types) store.types.forEach(gatherFields);
        }

        return fields;
    },

    /**
     * Returns the place in code where the field was declared
     * @returns {infer.AVal} The field config object
     */
    findDef: function() {
        var fieldName = this.node.value;

        var fieldObj = _.find(this.getFields(), function(obj) {
            return ASTUtil.findPropertyValue(obj, 'name') === fieldName;
        });

        if (fieldObj) {
            var result = new infer.AVal();
            result.origin = this.modelOrigin;
            result.span = ASTUtil.createSpan(fieldObj);
            return result;
        }
    }
};

module.exports = Field;

/**
 * Gets the store bound at the specified node
 * @param {Node} node A property value node
 * @returns {infer.Aval}
 */
function getBoundStore(dataIndexValueNode) {
    var configObj = dataIndexValueNode.parent && ASTUtil.getParentOfType(dataIndexValueNode.parent.parent, 'ObjectExpression', 5);

    if (configObj) {
        var store = getStoreFromBindExpression(configObj);
        if (!store) store = getStoreFromReference(configObj);
        return store;
    }
}

function getStoreFromReference(configObj) {
    var store = ASTUtil.findProperty(configObj, 'store');
    if (!store) return;

    if (store.type === 'Literal') {
        return new Store(store).findDef();
    } else if (store.type === 'ObjectExpression') {
        var type = ASTUtil.findProperty(store, 'type');
        return new Alias(type, cmdAutoDependencies.store).findDef();
    }
}

/**
 * @param {Node} obj A node of type="ObjectExpression"
 * @returns {*|infer.AVal}
 */
function getStoreFromBindExpression(configObj) {
    var bind = ASTUtil.findProperty(configObj, 'bind');
    if (!bind) return;
    var store = ASTUtil.findProperty(bind, 'store');
    if (!store) return;
    return new BindExpression(store).findDef()
}

/**
 * Returns the configs in an object expression as map of key name to value node.  Properties for keys ending in config
 * are returned as additional keys on the result.
 * @param {Node} configObj A node of type ObjectExpression
 * @returns {Object} key => node
 */
function getConfigs(configObj) {
    if (TypeUtil.isExtDefine(configObj)) {
        // move to the config object, for example in the case of a reference by short name, which returns the class definition
        configObj = configObj.arguments[1]
    } else if (configObj.type !== 'ObjectExpression') {
        // move to the object, for example in the case of a store id, which is a literal
        configObj = ASTUtil.getParentOfType(configObj, 'ObjectExpression');
    }

    var configs = {};

    for(var i=0; i<configObj.properties.length; i++) {
        var prop = configObj.properties[i];

        if (prop.key.name.match(/config$/i)) {
            if (prop.value && prop.value.type === 'ObjectExpression') {
                _.merge(configs, getConfigs(prop.value));
            }
        } else {
            configs[prop.key.name] = prop.value;
        }
    }

    return configs;
}
