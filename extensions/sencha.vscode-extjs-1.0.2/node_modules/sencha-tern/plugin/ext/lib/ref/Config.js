"use strict";

var TypeUtil = require('../TypeUtil'),
    ASTUtil = require('../ASTUtil'),
    _ = require('lodash'),
    infer = require('../../../../lib/infer');

function ConfigReference(node) {
    this.node = node;
}

ConfigReference.prototype = {

    /**
     * Returns all available events
     * @returns {Object[]}
     */
    getCompletions: function() {
        var obj = this.node.type === 'ObjectExpression' ? this.node : this.node.parent,
            isClassDefinition = TypeUtil.isExtDefine(obj && obj.parent),
            configs = configsFor(this.node, isClassDefinition),
            node = this.node;

        // remove current node from completion list, otherwise current token will always be shown (MVSP-86)
        configs = _.reject(configs, function(c) { return c._node === node; }.bind(this));

        var completions = configs.map(function(config) {
            return { name: config.name, type: config.type, access: config.access};
        });

        if (!isClassDefinition && !TypeUtil.createsInstance(this.node.parent)) {
            completions.push({name: 'xclass', type: 'String'});
        }

        if (ASTUtil.isConfigObject(obj)) {
            // remove type properties from config blocks
            var removeFromConfigs = ['xtype', 'xclass', 'type'];
            completions = _.filter(completions, function(item) {
                return removeFromConfigs.indexOf(item.name) === -1;
            });
        }

        for (var i=0; i<completions.length; i++) completions[i].reference='Config';

        return completions;
    },

    /**
     * Returns the place in code where the event was declared
     * @returns {infer.AVal} An object representing the config
     */
    findDef: function() {
        if (!this.node.key) return;

        var name = this.node.key.name;

        var match = _.find(configsFor(this.node), function(member) {
            return member.name === name;
        });

        if (match) {
            var result = new infer.AVal();
            result.addType(match);
            return result;
        }
    }
};

/**
 * Returns the configs available at the given node
 * @param {Node} node
 * @param {Boolean} forClassDefinition True if the node is a property in the config object parameter of a call to Ext.define.
 * @returns {Object[]}
 */
function configsFor(node, forClassDefinition) {
    if (node.type !== 'ObjectExpression') node = ASTUtil.getParentOfType(node, 'ObjectExpression');

    var types = TypeUtil.typesOf(node);
    var configs = TypeUtil.getMembers(types, 'config');

    if (!forClassDefinition) configs = _.filter(configs, function(c) {
        return c.access === 'public';
    });

    return configs;
}

module.exports = ConfigReference;