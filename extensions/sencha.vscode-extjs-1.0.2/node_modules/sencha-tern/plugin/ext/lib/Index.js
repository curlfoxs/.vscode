"use strict";
// change this to invalidate all indexes
var currentVersion = 60;

var _ = require('lodash'),
    fs = require('fs-extra'),
    visibility = require('./visibility'),
    path = require('path'),
    ignore = require('./ignore'),
    FileUtil = require('./FileUtil');

/**
 * Filters out all properties whose key starts with "_" when serializing JSON objects
 * @param key
 * @param value
 * @returns {*}
 */
function transientPropertyFilter(key, value) {
    if (key.match(/^_/)) return undefined;
    else return value;
}

/**
 * Allows efficient lookup and persistence of meta-data
 */
function Index(name, options) {
    _.assign(this, {
        persistent: true
    }, options);

    this.data = {};
    this.name = name;

    if (!global.tern.unitTest) {
        this.load();
    }
}

module.exports = Index;

Index.prototype = {

    /**
     * Returns only those keys which have entries that are visible to the current toolkit and app
     * @returns {String[]}
     */
    visibleKeys: function() {
        var result = [];

        for (var key in this.data) {
            if (this.data.hasOwnProperty(key)) {
                var entries = this.data[key];

                if (_.find(entries, function(entry) { return visibility.isVisible(entry.origin) })) {
                    result.push(key);
                }
            }
        }

        return result;
    },

    /**
     * Returns all keys in the index
     * @returns {String[]}
     */
    keys: function() {
        return Object.keys(this.data);
    },

    /**
     * Returns the values matching the specified key
     * @param {String} key
     * @param {Boolean} [includeInvisible=false] Set to true to return entries that are not visible given the current context
     * @returns {Object[]} the values
     */
    get: function(key, includeInvisible) {
        var found = this.data[key];
        if (!found) return [];
        if (!includeInvisible) found = _.filter(found, function(entry) { return !entry.origin || visibility.isVisible(entry.origin) });
        return found.map(function(e) { return e.value });
    },

    /**
     * Adds/updates a value in the index
     * @param {String} key
     * @param {Object} value
     * @param {String} origin The path to the file from which the value is derived
     */
    put: function(key, value, origin) {
        if (key === 'constructor') return;
        origin = origin && origin.toLowerCase(); // store origins in lower case so purging is case-insensitive

        var entries = this.data[key];

        if (entries === undefined) {
            entries = this.data[key] = [];
        }

        entries.push({ value: value, origin: origin });
    },

    /**
     * Deletes all values from the specified origin
     * @param {String} origin The path to the file for which entries should be deleted.
     */
    purge: function(origin) {
        origin = origin.toLowerCase();

        for (var key in this.data) {
            if (this.data.hasOwnProperty(key)) {
                var entries = this.data[key];
                _.remove(entries, function(item) { return item.origin === origin });
                if (entries.length === 0) delete this.data[key];
            }
        }
    },

    /**
     * Loads index data from the file
     */
    load: function() {
        if (!this.persistent) return;

        var file = this.getFile();

        if (file && fs.existsSync(file)) {
            var json = fs.readFileSync(file, 'utf8');
            var contents = {};

            try {
                contents = JSON.parse(json);
            } catch(e) {
                console.log('Could not load data from ' + file);
            }

            // don't load data created with an old version of the indexing logic
            if (contents.version === currentVersion) {
                this.data = contents.data;
            }
        }
    },

    /**
     * Returns the path to the persisted file
     * @returns {string}
     */
    getFile: function() {
        return FileUtil.tempDir && path.join(FileUtil.tempDir, this.name + '.json')
    },

    /**
     * Writes the index to a file
     */
    persist: function() {
        if (this.persistent) {
            var contents = JSON.stringify({
                version: currentVersion,
                data: this.data
            }, transientPropertyFilter);

            fs.writeFileSync(this.getFile(), contents, 'utf8');
        }
    },

    /**
     * Removes all entries from the index
     */
    clear: function() {
        this.data = {};
    },

    /**
     * Removes entries for all deleted files
     */
    pruneDeleted: function() {
        for (var key in this.data) {
            if (this.data.hasOwnProperty(key)) {
                var entries = this.data[key] = _.filter(this.data[key], function(entry) {
                    return fs.existsSync(entry.origin);
                });

                if (entries.length === 0) delete this.data[key];
            }
        }
    }
};