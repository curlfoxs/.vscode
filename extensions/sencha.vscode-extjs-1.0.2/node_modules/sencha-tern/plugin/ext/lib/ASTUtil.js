"use strict";

var _ = require('lodash');
var walk = require('acorn/dist/walk');
var infer = require('../../../lib/infer');
var fs = require('fs');
var walkall = require('walkall');
var comment = require('../../../lib/comment');
var util = require('./util');

/**
 * Adds keyName to node.  This makes the different between symbol and literal property names transparent.
 * For example prop.keyName will be the same for:
 *
 * 'foo': function() {}
 *
 * and
 *
 * foo: function() {}
 */
Object.defineProperty(require('acorn/dist/acorn').Node.prototype, 'keyName', {
    get: function() {
        if (!this.key) {
            return undefined;
        } else if (this.key.type === 'Literal') {
            return this.key.value.toString();
        } else {
            return this.key.name;
        }
    }
});

/**
 * Utility methods for working with the acorn AST
 */
var ASTUtil = {

    /**
     * Returns true if the call is to a constructor
     * @param {Node} call
     * @returns {Boolean}
     */
    isConstructorCall: function(call) {
        return call.type === 'NewExpression';
    },

    /**
     * Gets the value of a property in an object literal.
     * @param {ObjectExpression} obj and object literal node
     * @param {String[]} names The name of the property to find
     * @return {Node}
     */
    findProperty: function(obj, names) {
        if (!obj || obj.type !== 'ObjectExpression') return null;
        if (!_.isArray(names)) names = [names];

        var propNode = _.find(obj.properties, function(property) {
            return names.indexOf(property.key.name) !== -1;
        });

        return propNode ? propNode.value : null;
    },

    /**
     * Returns the value of the specified property, either as a string or array
     * @param {ObjectExpression} obj and object literal node
     * @param {String[]} names The name of the property to find
     * @returns {String/String[]}
     */
    findPropertyValue: function(obj, names) {
        var prop = ASTUtil.findProperty(obj, names);

        if (!prop) {
            return null;
        } else if (prop.type == 'Literal') {
            return prop.value;
        } else {
            return null;
        }
    },

    /**
     * Returns the first ancestor of the specified type
     * @param {Node} node
     * @param {String} type
     * @param {Integer} [maxHeight] The maximum height to climb in the tree before returning null
     * @returns {Node}
     */
    getParentOfType: function(node, type, maxHeight) {
        var height = 0;

        while (node = node.parent) {
            if (maxHeight && height++ > maxHeight) return null;
            if (node.type === type) return node;
        }
    },

    /**
     * Returns an array of values when node is an ArrayExpression or a single value array when the node is a Literal
     * @param {Node} node An ArrayExpression or Literal
     * @returns {String[]}
     */
    getLiteralValues: function(node) {
        if (node.type === 'ArrayExpression') {
            return node.elements.map(function(el) { return el.value; });
        } else if (node.type == 'Literal') {
            return [node.value];
        } else {
            return []
        }
    },

    /**
     * Returns the name of the parent property in which the cursor resides.  For example, given:
     *
     * fields: [{
     *  <cursor>
     * }]
     *
     * returns "fields"
     *
     * @param node
     * @returns {String}
     */
    getParentPropertyName: function(node) {
        if (node.parent.type === 'Property') {
            return node.parent.key.name;
        } else {
            node = node.parent.parent.type === 'ArrayExpression' ? node.parent.parent.parent : node.parent.parent;
            if (node.type === 'Property') return node.key.name;
        }
    },

    /**
     * Returns memberExpression as a fully-qualified string.  E.g  MyApp.foo.Bar.prototype => "MyApp.foo.Bar.prototype";
     * @param memberExpression
     * @returns {string}
     */
    getFullyQualifiedName: function(memberExpression) {
        if (memberExpression) {
            if (memberExpression.type === 'Identifier') return memberExpression.name;

            var name = [];
            if (memberExpression.object) name.push(ASTUtil.getFullyQualifiedName(memberExpression.object));
            if (memberExpression.property) name.push(memberExpression.property.name);
            return name.join('.');
        }
    },

    /**
     * Reads and parses a file
     * @param {String} file A file path
     * @param {Integer/String} [offset] If specified, the returned value will be the element at this offset.  This can also be a span string.
     * @returns {Node} The root node, or if offset is specified, the node at the offset
     */
    parse: function(file, /* optional */ offset) {
        if (global.tern.requestCache === undefined) global.tern.requestCache = {};

        var key = 'ast:' + file,
            ast = global.tern.requestCache[key];

        if (!ast) {
            if (!fs.existsSync(file)) return null;
            var text = util.readFileSyncNoBOM(file);
            ast = global.tern.requestCache[key] = infer.parse(text);
            ast.sourceFile = { name: file };
            ASTUtil.postParse(ast, text);
        }

        if (typeof(offset) === 'string') {
            // offset is a span
            offset = parseInt(offset.split('-')[1].replace(/\[.*$/g, ''));
        }

        if (offset !== undefined) {
            var found = infer.findExpressionAt(ast, null, offset);
            return found && found.node;
        } else {
            return ast;
        }
    },

    /**
     * Ensures that comments are attached to each ast node so that the plugin can extract type data from them. Also
     * adds a parent property to each ast node
     * @param {ast} ast
     * @param {String} text
     */
    postParse: function(ast, text) {
        var commentBlock = /\/\*{2}([\s\S]+?)\*\//g,
            processedOffsets = {};

        function attachCommentsBefore(node) {
            comment.ensureCommentsBefore(text, node);

            if (node.comments) {
                for (var i=0; i<node.comments.length; i++) {
                    // keep track of comments assigned to nodes so we don't assign them as inner comments later
                    processedOffsets[node.comments[i].end] = true;
                }
            }
        }

        var commentVisitors = {
            ObjectExpression: function(node) {
                attachCommentsBefore(node)
                node.properties.forEach(attachCommentsBefore);
            }
        };

        try {
            walk.ancestor(ast, walkall.makeVisitors(function(node, state) {
                node.sourceFile = ast.sourceFile;
                if (state.length > 1) {
                    node.parent = state[state.length-2];
                }
                var commentVisitor = commentVisitors[node.type] || attachCommentsBefore;
                commentVisitor(node);
            }));

            walk.simple(ast, walkall.makeVisitors(function (node) {
                var match, nodeText = text.slice(node.start, node.end);
                node.innerComments = node.innerComments || [];

                while ((match = commentBlock.exec(nodeText)) != null) {
                    var c = match[0],
                        commentEnd = node.start + match.index + c.length;

                    if (!processedOffsets[commentEnd]) { // only assign as an inner comment if it hasn't already been assigned to a node
                        processedOffsets[commentEnd] = true;
                        node.innerComments.push({
                            type: 'Comment',
                            parent: node,
                            start: node.start + match.index,
                            end: commentEnd,
                            text: c.slice(2, c.length - 2) // remove comment start and end to match the way that tern's comment.ensureCommentsBefore behaves,
                        });
                    }
                }
            }));
        } catch (e) {
            console.log('Error parsing ' + ast.sourceFile.name);
            throw e;
        }
    },

    /**
     * If the property node has a string value, it is returned.  When the value is an object literal, the value of the type property is returned.
     * @param propNode
     * @returns {String}
     */
    getValueOrType: function(valueNode) {
        if (valueNode.type === 'ObjectExpression') {
            return ASTUtil.findPropertyValue(valueNode, "type");
        } else {
            return valueNode.value;
        }
    },

    /**
     * Returns the position of the end of the word at the given caret position
     * @param {Node} literal A literal node
     * @param {Integer} pos
     * @returns {Integer}
     */
    findWordEnd: function(literal, pos) {
        var text = literal.sourceFile.text;

        while (pos < literal.end) {
            var atPos = text[pos];
            if (atPos.match(/\W/)) return pos;
            pos++;
        }

        return pos-1;
    },

    /**
     * Returns true if the specified node is a config object
     * @param node
     */
    isConfigObject: function(node) {
        return  node.type === 'ObjectExpression' &&
                node.parent !== undefined &&
                node.parent.type === 'Property' &&
                node.parent.key &&
                node.parent.key.name &&
                node.parent.key.name.match(/([cC]onfig$|^bind$)/);
    },

    /**
     * Creates a span string for the specified node
     * @param {Node} node
     * @returns {string}
     */
    createSpan: function(node) {
        if (node) {
            if (node.parent && node.parent.type === 'Property') node = node.parent; // favor parents for definition lookup - it looks nicer
            return node.start + '[0:0]-' + node.end + '[0:0]'
        }
    }
};

module.exports = ASTUtil;