'use strict';

var fs = require('fs-extra'),
    path = require('path'),
    _ = require('lodash'),
    stripJsonComments = require('strip-json-comments'),
    jsonic = require('jsonic'),
    propertiesParser = require('properties-parser'),
    util = require('./util'),
    slash = require('slash'),
    FileUtil = require('./FileUtil');

/**
 * An array of objects describing the apps that tern is indexing/watching.
 * @type {Object[]}
 */
var apps;

/**
 * An array of sdk objects.
 * @type {Array}
 */
var sdks;

/**
 * The name of the file used to configure tern
 * @type {string}
 */
var CONFIG_FILE;

/**
 * Keep track of the stringified contents of the config file when it was loaded.  Only reload if the content has changed.
 */
var lastConfigContents;

// only set up one watcher for the config file
var watchingConfigFile = false;

var watchConfig = true,
    watchConfigArg = process.argv.indexOf("--watchConfig");

if (watchConfigArg > -1) {
    if (process.argv[watchConfigArg + 1] === 'false') {
        /*
         * In order to better support network shares, for which we do not get file system events, 
         * we give the option to not watch config.json and rely on the IDE to call /reset when the config
         * file changes, as in the case of Visual Studio Code.
         */
        watchConfig = false;
    }
}

/**
 * Loads .sencha/ide/config.json and watches that file for changes.
 * @param {tern.Server} the tern server
 * @returns {Object} The contents of config.json
 */
module.exports = function(server) {
    CONFIG_FILE = path.join(FileUtil.resourcesDir, 'config.json');

    copyOldConfigFileIfExists();

    //create sencha-ide-config file
    if (!fs.existsSync(CONFIG_FILE) && !global.tern.unitTest) {
        createIdeConfig();
    }

    if (watchConfig && fs.existsSync(CONFIG_FILE) && !watchingConfigFile) {
        watchingConfigFile = true;

        fs.watch(CONFIG_FILE, function(event, filename) {
            var contents = JSON.stringify(readJson(filename));

            // don't reload on trivial changes or metadata changes (maven can do this)
            if (lastConfigContents !== contents) {
                lastConfigContents = contents;
                console.log(filename + ' modified, restarting tern...');
                server.reset();
            }
        });
    }

    return initialize(server.options);
};

var config;

/**
 * Processes config.json, discovers all apps in the current working directory and ensures that the ext plugin is enabled.
 * @param {Object} the tern config object
 * @returns {Object} The contents of config.json
 */
function initialize(ternConfig) {
    apps = global.tern.apps = [];
    sdks = global.tern.sdks = [];
    config = loadSenchaIdeConfig();
    if (_.isArray(config.include)) config.include.forEach(findApps);
    if (_.isArray(config.apps)) config.apps.forEach(mergeApp);

    _.defaultsDeep(ternConfig, {
        plugins: {
            ext: { }
        }
    });

    // ensure that all referenced sdks are indexed, even if they are outside of the project
    apps.forEach(function(app) {
        var sdk = app.sdk && app.sdk.path;
        if (sdk && config.include.indexOf(sdk) === -1) config.include.push(sdk)
    });

    console.log('contents after postprocessing:');
    console.log(JSON.stringify(config, null, '\t'));

    console.log('Found apps:');
    console.log(JSON.stringify(apps, null, '\t'));

    return config;
}

/**
 * Copy config.json file from resources/config.json
 */
function createIdeConfig() {
    var ideSampleConfigFile = path.join(__dirname, '..', "resources", "config.json");
    var contents = fs.readFileSync(ideSampleConfigFile, 'utf-8');

    if (contents) {
        fs.writeFileSync(CONFIG_FILE, contents);
    } else {
        console.log('Error reading sample ide config file');
    }
}

/**
 * Copies the old .sencha-ide-config file if one exists to its new location in .sencha/ide/config.json.
 * The contents of the old .sencha-ide-config file are replaced with a message announcing the new location
 */
function copyOldConfigFileIfExists() {
    var oldFile = path.join(process.cwd(), '.sencha-ide-config');

    if (fs.existsSync(oldFile) && !fs.existsSync(CONFIG_FILE)) {
        fs.copySync(oldFile, CONFIG_FILE);
        fs.writeFileSync(oldFile, '/*\nThis file has been permanently moved to ' + CONFIG_FILE + '.  You can delete this file.\n*/');
    }
}

/**
 * Reads and validates config.json in the current working directory
 * @returns {Object}
 */
function loadSenchaIdeConfig() {
    var config = {};

    try {
        if (fs.existsSync(CONFIG_FILE)) {
            console.log('found config.json at ' + path.resolve(CONFIG_FILE));
            config = readJson(CONFIG_FILE);
            lastConfigContents = JSON.stringify(config);
            console.log('contents:');
            console.log(JSON.stringify(config, null, '\t'));
        } else {
            console.log('could not find config.json in ' + process.cwd());
        }

        _.defaults(config, {
            /**
             * @property {String[]} include Paths containing source code to index and monitor.
             */
            include: [],
            apps: [],
            exclude: []
        });

        if (_.isArray(config.paths)) { // handle legacy "paths" config from 6.0.1, which was renamed "include" in 6.0.2
            config.include = config.paths.concat(config.include)
        }

        if (config.apps && !_.isArray(config.apps)) {
            throw new Error("Error in config.json: apps must be an array");
        }

        if (config.include && !_.isArray(config.include)) {
            throw new Error("Error in config.json: include must be an array");
        }

        if (config.exclude && !_.isArray(config.exclude)) {
            throw new Error("Error in config.json: exclude must be an array");
        }

        // convert relative paths to absolute
        config.include = [process.cwd()].concat(config.include.map(function (p) {
            return path.resolve(p);
        }));

        // add directories from --include (this is used by Sencha Test to index the ST api)
        var includeParam = process.argv.indexOf('--include');
        if (includeParam !== -1) {
            var include = process.argv[includeParam + 1];
            config.include = config.include.concat(include.split(/,\s*/));
        }

        console.log('include', config.include);

        config.exclude = config.exclude.map(function (p) {
            return path.resolve(p);
        });

        // add sdks and app paths to paths if they are not already there
        if (config.apps) config.apps.forEach(function(app) {
            if (app.sdk && app.sdk.path) {
                app.sdk.path = path.resolve(app.sdk.path) + path.sep; // convert relative paths to absolute paths

                if (!_.find(config.include, function(p) { return util.equalsIgnoreCase(p, app.sdk.path)})) {
                    config.include.push(app.sdk.path);
                }
            }

            if (app.path) {
                app.path = path.resolve(app.path); // convert relative paths to absolute paths

                if(!_.find(config.include, function(p) { return util.equalsIgnoreCase(p, app.path)})) {
                    config.include.push(app.path);
                }
            }
        });
    } catch(e) {
        console.error('config.json could not be parsed.  Tern shutting down...');
        process.exit(78); // this lets the plugin know to display a friendly error message about config.json being invalid
    }

    return config;
}

/**
 * Finds an existing app by path
 * @param {String} appToFind
 * @return {Object} An app object
 */
function findApp(path) {
    return _.find(apps, function(app) { return util.equalsIgnoreCase(app.path, path); })
}

/**
 * Merges an app from config.json with a found app with the same path, converting relative paths to absolute paths
 * @param {Object} configApp App configuration from config.json
 */
function mergeApp(configApp) {
    var match = findApp(configApp.path);

    if (match) {
        _.merge(match, configApp);
    } else {
        apps.push(configApp);
    }
}

/**
 * Rerturns true for hidden directories and subdirectories of those listed in config.exclude
 * @param {String} dir
 * @returns {boolean}
 */
function isExcluded(dir) {
    return slash(dir).indexOf('/node_modules') !== -1 || isHidden(dir) || _.isArray(config.exclude) && config.exclude.some(function(excludePath) {
        return util.startsWithIgnoreCase(dir, excludePath)
    });
}

/**
 * Checks whether a path starts with or contains a hidden file or a folder.
 * @param {string} source - The path of the file that needs to be validated.
 * returns {boolean} - `true` if the source is blacklisted and otherwise `false`.
 */
function isHidden(path) {
    return (/(^|\/)\.[^\/\.]/g).test(path);
}

/**
 * Populates apps with information about all Ext JS apps in the given directory
 * @param {String} dir A directory path to search
 */
function findApps(dir) {
    if (isExcluded(dir)) return;

    if (fs.existsSync(dir)) {
        var files = fs.readdirSync(dir);
        var app = files.indexOf('app.json') !== -1 ? 'app.json' : undefined;

        if (app) {
            app = createApp(dir, app);
            if (app && !findApp(app.path)) apps.push(app);
        } else {

            // if the package is an sdk, add it to global.tern.sdks
            if (files.indexOf('package.json') !== -1) {
                var packageData = readJson(path.join(dir, 'package.json'));

                if (packageData && packageData.type === 'framework') {
                    sdks.push({ path: dir, framework: packageData.name === 'touch' ? 'touch' : 'extjs', version: packageData.version });
                }
            }

            files.filter(function(f) {
                try {
                    return fs.statSync(path.join(dir, f)).isDirectory();
                } catch (e) {
                    // rollbar reports that sometimes statSync will fail if the file is unreadable
                }
            }).forEach(function(subDir) {
                findApps(path.join(dir, subDir));
            });
        }
    }
}

/**
 * Creates an object holding important info about an Ext JS app
 * @param dir
 * @param appFile
 * @returns {Object}
 */
function createApp(dir, appFile) {
    var appData = readJson(path.join(dir, appFile));

    if (appData && appData.name) {
        var sdk = findSdk(dir, appData);

        return {
            path: path.resolve(dir + '/'),
            sdk: sdk,
            toolkit: findToolkit(dir),
            name: appData.name
        };
    }
}

/**
 * Reads a json file - comments allowed.  Returns null if the file could not be read
 * @param {String} file A file path
 * @param {Object}
 */
function readJson(file) {
    try {
        return jsonic(stripJsonComments(fs.readFileSync(file, 'utf8')));
    } catch(e) {
        return null;
    }
}

/**
 * Returns the toolkit for the specified app root directory.  Will return "core" if no toolkit is defined in app.json or package.json
 * @param {String} appDir The path to the root directory of an app or package
 * @returns {String}
 */
function findToolkit(appDir) {
    var file = _.find(['app.json', 'package.json'], function(file) {
        return fs.existsSync(path.join(appDir, file));
    });

    if (file) {
        var contents = readJson(path.join(appDir, file));

        if (contents) {
            if (contents.toolkit === 'classic') {
                return 'classic';
            } else if (contents.toolkit === 'modern') {
                return 'modern';
            } else {
                return undefined;
            }
        } else {
            console.warn("Could not parse " + path.join(appDir, file));
        }
    }
}

function findWorkspaceJson(appDir) {
    var workspaceJsonPath = path.join(appDir, 'workspace.json');
    var contents = readJson(workspaceJsonPath);

    if (contents) return { path: workspaceJsonPath, contents: contents };

    workspaceJsonPath = path.join(appDir, '..', 'workspace.json');
    contents = readJson(workspaceJsonPath);

    if (contents) return { path: workspaceJsonPath, contents: contents };

    return null;
}

/**
 * Uses the bootstrap file (boostrap.json, classic.json, or modern.json) to derive the sdk path for the app
 * in the specified directory
 * @param {String} dir The path to an app directory
 * @param {Object} appData The contents of the app.json file
 * @return {String} The full path to the sdk
 */
function findSdk(dir, appData) {
    var workspaceJson = findWorkspaceJson(dir),
        sdkPath;

    if (workspaceJson) {
        var workspaceData = workspaceJson.contents,
            framework = workspaceData.frameworks && workspaceData.frameworks[appData.framework];

        if (framework) {
            sdkPath = framework.source || framework.path || framework; // see comments in workspace.json

            if (typeof sdkPath === 'string') {
                sdkPath = path.join(path.dirname(workspaceJson.path), sdkPath);
            } else {
                sdkPath = null;
            }

            return {
                path: sdkPath,
                framework: appData.framework.indexOf('touch') !== -1 ? 'touch' : 'extjs',
                version: getSdkVersion(sdkPath)
            }
        }
    }

    sdkPath = guessSdkPath(dir);

    return sdkPath && {
        path: sdkPath,
        framework: sdkPath.indexOf('touch') !== -1 ? 'touch' : 'extjs',
        version: getSdkVersion(sdkPath)
    };
}

/**
 * Returns the value of the version prop from the specified json file
 * @param {packageDir} file The path to the package
 * @returns {String}
 */
function getSdkVersion(packageDir) {
    var data = readJson(path.join(packageDir, 'package.json'));
    var version = data && data.version;

    if (!version) {
        var cfgFile = path.join(packageDir, 'cmd', 'sencha.cfg');
        if (fs.existsSync(cfgFile)) version = readVersionFromProperties(cfgFile)
    }

    return version;
}

/**
 * Reads the framework version from sencha.cfg
 * @param {String} file The path to sencha.cfg
 * @returns {String}
 */
function readVersionFromProperties(file) {
    return propertiesParser.read(file)['framework.version'];
}

/**
 * Looks for ext or touch directories within the app, or in the parent directory (presumably the workspace directory)
 * @param {String} dir The path to an app directory
 * @returns {String}
 */
function guessSdkPath(dir) {
    if (fs.existsSync(path.join(dir, 'ext', 'cmd', 'sencha.cfg'))) return path.join(dir, 'ext');
    if (fs.existsSync(path.join(dir, '..', 'ext', 'cmd', 'sencha.cfg'))) return path.join(dir, '..', 'ext');
    if (fs.existsSync(path.join(dir, 'touch', 'cmd', 'sencha.cfg'))) return path.join(dir, 'touch');
    if (fs.existsSync(path.join(dir, '..', 'touch', 'cmd', 'sencha.cfg'))) return path.join(dir, '..', 'touch');
}
