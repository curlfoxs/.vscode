var _ = require('lodash'),
    stripBOM = require('strip-bom'),
    fs = require('fs');

module.exports = {

    /**
     * Reads a file and strips the BOM, which can cause issues w/ Visual Studio as it doesn't send the BOM,
     * so offsets would be 1 character different when read from the fs vs pushed from VS
     * @param file
     * @returns {String}
     */
    readFileSyncNoBOM: function(file) {
        return stripBOM(fs.readFileSync(file, 'utf8'));
    },

    /**
     * Case-insensitive equals comparing two strings
     * @param {String} a
     * @param {String} b
     * @returns {Boolean}
     */
    equalsIgnoreCase: function(a, b) {
        return a && b && a.toLowerCase() === b.toLowerCase();
    },

    /**
     * Returns true if the array contains the item, ignoring case
     * @param {String[]} array
     * @param {String} item
     * @returns {Boolean}
     */
    containsIgnoreCase: function(array, item) {
        return item && array.map(function(i) { return i.toLowerCase(); }).indexOf(item.toLowerCase()) !== -1;
    },

    /**
     * Returns true if a starts with b, ignoring case
     * @param {String} a
     * @param {String} b
     * @returns {Boolean}
     */
    startsWithIgnoreCase: function(a, b) {
        return a && b && a.toLowerCase().indexOf(b.toLowerCase()) === 0;
    },

    /**
     * Returns a string with all occurrences of toReplace replaced with replacement in the source string
     * @param {String} source The source string
     * @param {String} toReplace The substring to replace
     * @param {String} replacement The replacement string
     * @returns {String}
     */
    replaceAll: function(source, toReplace, replacement) {
        var regex = new RegExp(_.escapeRegExp(toReplace), 'g');
        return source.replace(regex, replacement)
    },

    /**
     * Returns offsets from a span
     * @param {String} span
     * @returns {{start: (string|*), end: (string|*)}}
     */
    createOffsets: function(span) {
        var arr = span.replace(/\[.*?\]/g,'').split('-');
        return arr && arr.length == 2 ? { start: parseInt(arr[0]), end: parseInt(arr[1]) } : {};
    }
};