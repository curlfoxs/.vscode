"use strict";

var _ = require('lodash');
var fs = require('fs-extra');
var extract = require('./extract');
var load = require('./load');
var infer = require('../../../lib/infer');
var walk = require('acorn/dist/walk');
var indexes = require('./indexes');
var path = require('path');
var IndexUtil = require('./IndexUtil');
var ASTUtil = require('./ASTUtil');
var util = require('./util');
var slash = require('slash');
var FileUtil = require('./FileUtil');

var lastPctComplete = -1;
var writeStatusFile = true;
var writeStateFileArg = process.argv.indexOf("--writeStatusFile");

// give the option of not writing the progress file for plugins that are listening to stdout
if (writeStateFileArg > -1) {
    if (process.argv[writeStateFileArg + 1] === 'false') {
        writeStatusFile = false;
    }
}

/**
 * @param {tern.Server} server A reference to the tern server
 * @param {Object} config The contents of .sencha-ide-config
 * @constructor
 */
function FileProcessor(server, config) {
    updateStatus(0, 1);
    this.include = config.include;

    /**
     * Paths that should not be indexed
     * @type {String[]}
     */
    this.exclude = (config.exclude || []).map(function(p) { return path.resolve(p) });

    /**
     * Files that tern shouldn't analyze - typically sdk files, which tern will mess up
     * @type {String[]}
     */
    this.dontAnalyze = this.exclude.slice(0);

    global.tern.apps.forEach(function(app) {
        if (app.sdk && app.sdk.path) {
            this.dontAnalyze.push(app.sdk.path);
            this.exclude.push(app.sdk.path + 'examples');
            this.exclude.push(app.sdk.path + 'docs');
            this.exclude.push(app.sdk.path + 'templates');
        }
    }.bind(this));

    this.server = server;
    infer.withContext(this.server.cx, this.doEagerLoading.bind(this));

    if (!global.tern.unitTest) {
        // save indexes when tern quits
        process.on('exit', this.persistIndexes.bind(this));
    }
}

/**
 * Writes the indexing status to a file so that plugins can report this to the user during startup
 * @param {Integer/Boolean} done The number of files indexed or true to indicate that all files have been processed
 * @param {Integer} [total] The total number of files to index
 */
function updateStatus(done, total) {
    var pctComplete = done === true ? 100 : Math.round(done/total * 100);
    if (process.send) process.send({pctComplete: pctComplete}); // this is helpful when tern is run as a child process - for example, in ext-ace (Orion)

    if (lastPctComplete !== pctComplete) {
        lastPctComplete = pctComplete;

        if (writeStatusFile) {
            fs.writeFileSync(path.join(FileUtil.tempDir, 'status.json'), JSON.stringify({ pctComplete: pctComplete }));
        } else {
            console.log('Indexing ' + pctComplete + '% complete.')
        }
    }
}

/**
 * Returns true if the file is at least 500 characters and has less than 2 newlines in the first 500 characters
 * @param {String} text The file contents
 * @return {Boolean}
 */
function isProbablyBuildFile(text) {
    if (text.length < 1000) return false;
    if (text.length > 500000) return true;

    var newlines = 0;

    // sometimes minified files start with a comment - take this out before counting newlines
    var withoutComments = text.replace(/^\s*\/\*([\s\S]+?)\*\/\s*/, '');

    for (var i=0; i<withoutComments.length; i++) {
        if (withoutComments[i] === '\n') {
            newlines++;
        }
    }

    return withoutComments.length / newlines > 1000;
}

FileProcessor.prototype = {

    /**
     * Ensures that excluded and sdk files are not processed by tern. Some files like bootstrap.js can destroy
     * tern's internal model if indexed.
     * @param file
     * @returns {boolean}
     */
    beforeLoad: function(file) {
        if (
            isProbablyBuildFile(file.text) ||
            this.dontAnalyze.some(function(p) { return util.startsWithIgnoreCase(file.name, p) })
            || !this.shouldIndex(file.name)
        ) {
            return false;
        }
    },

    /**
     * Removes data from the specified files from all indexes.  Elements in the origins array will be
     * changed to "do not purge" if they are sdk files.  This prevents tern from wiping out data from sdk
     * classes if the user attempts to autocomplete or alter and sdk class.
     * @param {String[]} origins
     */
    purge: function(origins) {
        for (var i=0; i<origins.length; i++) {
            var file = origins[i];

            // don't purge excluded files (for example sdks) or they will never be reloaded if they are also in include
            if (this.dontAnalyze.some(function(p) { return util.startsWithIgnoreCase(file, p); })) {
                origins[i] = "do not purge";  // change file name so tern doesn't purge it
            } else {
                IndexUtil.purge(file);
            }
        }
    },

    /**
     * Extracts metadata from the file and adds it to the index
     * @param {String} file The full path to the file
     */
    index: function(file) {
        if (!this.shouldIndex(file)) return;

        var entries = indexes.file.get(file, true),
            cached = entries && entries[0],
            stats = fs.lstatSync(file);

        if (stats.isDirectory()) return;

        if (!cached || stats.mtime > new Date(cached.timestamp)) {
            console.log('indexing ' + file);
            var text = util.readFileSyncNoBOM(file);

            if (isProbablyBuildFile(text)) {
                console.log('Skipping ' + file + ' - probably minified');
                return;
            }

            var ast = infer.parse(text),
                sourceFile = { name: file, ast: ast };

            ast.sourceFile = sourceFile;
            this.postParse(ast, text);
            this.infer(ast, text, false);
        } else {
            this.loadAll(cached.defs);
        }
    },

    /**
     * Watches files listed in loadEagerly
     */
    doEagerLoading: function() {
        global.tern.unleashTheFury = false;

        var files =  _.flatten(this.include.map(function(p) {
            if (fs.existsSync(p)) {
                return fs.walkSync(p);
            } else {
                return [];
            }
        })).filter(function(file) {
            return file.indexOf('.sencha') === -1 && /\.(js)$/.test(file);
        }).filter(function(file) {
            return !this.isExcluded(file); // exclude files in directories in exclude array from .sencha-ide-config
        }.bind(this));

        console.log('loading ' + files.length + ' js files in project...');
        var start = new Date().getTime();

        for (var i=0; i<files.length; i++) {
            try {
                if (i % 10 === 0) {
                    // only write new status every 10 files to improve startup time
                    updateStatus(i, files.length);
                }

                this.index(path.resolve(files[i]));
            } catch (e) {
                // an error when indexing a single file shouldn't stop indexing
                console.log("Error indexing " + files[i], e);
            }
        }

        var end = new Date().getTime();
        console.log('project loaded in ' + (end-start)/1000.0 + ' seconds');
        updateStatus(true);
        global.tern.unleashTheFury = true;

        // persist indexes at startup so we don't have to parse again if tern crashes and can't persist.
        this.persistIndexes();
    },

    /**
     * Ensures that comments are attached to each ast node so that the plugin can extract type data from them. Also
     * adds a parent property to each ast node
     * @param {ast} ast
     * @param {String} text
     */
    postParse: function(ast, text) {
        if (!this.shouldIndex(ast.sourceFile.name)) return;
        ASTUtil.postParse(ast, text);
    },

    /**
     * Extracts type metadata from the given file
     * @param {Node} ast
     * @param {String} text
     * @param {Boolean} force True to skip the cache and force reanalysis
     */
    infer: function(ast, text, force) {
        var file = ast.sourceFile.name;
        if (!this.shouldIndex(file)) return;

        // since files only scanned by the plugin at startup are not registered with the server, they won't
        // automatically get purged the first time, so we need to do a manual purge
        infer.purge([file]);
        var defs = extract(ast);
        indexes.file.put(file, { timestamp: new Date(), defs: defs }, file);
        this.loadAll(defs);
    },

    /**
     * Loads all definitions into tern's data model
     * @param {Object[]} defs
     */
    loadAll: function(defs) {
        for (var className in defs) {
            load(defs[className]);
        }
    },

    /**
     * Saves all indexes to the file system
     */
    persistIndexes: function() {
        _.forOwn(indexes, function(index, name) {
            if (index.persist) {
                try {
                    index.persist();
                } catch(e) {
                    // if for some reason an index cannot be persisted, we shouldn't stop all persistence.
                }
            }
        });

        console.log('wrote indexes');
    },

    // private

    /**
     * Returns true if the specified file should be indexed
     * @param {String} file A file path
     * @returns {Boolean}
     */
    shouldIndex: function(file) {
        file = slash(file);
        return !this.isExcluded(file) && !this.isBuildProduct(file) && !this.isTest(file) && !this.isLocale(file)
    },

    /**
     * Returns true if the file is a sencha cmd build product.  Minified files should not be indexed.
     * @param {String} file A file path
     * @returns {Boolean}
     */
    isBuildProduct: function(file) {
        var name = path.basename(file);

        if (name.indexOf('sencha-touch') === 0 || name.indexOf('ext-') === 0 || name === 'ext.js') return true;

        var packageRoot = this.packageRootFor(file);

        if (!packageRoot) return false;

        return  file.indexOf(packageRoot + '/build/') === 0 ||
                file.indexOf(packageRoot + '/examples/build/') === 0 ||
                file.indexOf(packageRoot + '/docs/output') === 0 ||
                file.indexOf(packageRoot + '/sass/example/bootstrap.js') === 0 ||
                file.indexOf(packageRoot + '/bootstrap.js') === 0;
    },

    /**
     * Returns true if the source file is a unit test
     * @param {String} file A file path
     * @returns {Boolean}
     */
    isTest: function(file) {
        return  file.match(/(sencha-|ext-).*\/(test|specs?)\//) || // ext 5, touch 2
            file.match(/ext\/packages\/.*\/(test|specs?)\//) || // ext6
            file.match(/ext\/(classic\/classic|modern\/modern)\/test\//) // ext6
    },

    /**
     * Returns true if the file is a localization file.
     * @param {String} file A file path
     * @returns {Boolean}
     */
    isLocale: function(file) {
        return file.indexOf('ext-locale-') === 0
    },

    /**
     * Returns true if the file is one of the known excluded files
     * @param {String} file A file path
     * @returns {Boolean}
     */
    isExcluded: function(file, ignoreExplicitInclude) {
        file = slash(file);
        if (file.indexOf('/node_modules') !== -1 && (ignoreExplicitInclude || !this.isExplicitlyIncluded(file))) return true;

        for (var i=0; i<this.exclude.length; i++) {
            if (file.indexOf(slash(this.exclude[i])) === 0) {
                console.log('Skipping ' + file + ', reason: matched excluded path "' + this.exclude[i] + '"')
                return true;
            }
        }

        return file.indexOf('ext-charts') !== -1;
    },

    /**
     * Returns true if
     * @param file
     * @returns {*|boolean}
     */
    isExplicitlyIncluded: function(file) {
        file = slash(file);
        return this.include.some(function(p) {
            p = slash(p);
            var relativePath = file.slice(p.length, file.length);
            return file.indexOf(p) === 0 && !this.isExcluded(relativePath, true);
        }.bind(this));
    },

    /**
     * Finds the root dir of the package containing the specified file
     * @param {String} file A file path
     * @returns {String}
     */
    packageRootFor: function(file) {
        while (fs.existsSync(file)) {
            if (fs.existsSync(path.join(file, '.sencha', 'app') || fs.existsSync(path.join(file, '.sencha', 'package')))) {
                return slash(file);
            } else {
                var parentDir = path.resolve(path.join(file, '..'));
                if (parentDir == file) return; // happens in the case of "/"
                if (file === process.cwd()) return; // stop looking once we hit the project root
                file = parentDir;
            }
        }
    }
};

module.exports = FileProcessor;

