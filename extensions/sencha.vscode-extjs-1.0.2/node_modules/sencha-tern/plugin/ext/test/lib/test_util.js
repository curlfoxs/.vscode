"use strict";

var acorn = require('acorn');
var fs = require('fs-extra');
var tern = require('../../../../lib/tern');
var resolve = require('resolve');
var chai = require('./chai_setup');
var _ = require('lodash');
var infer = require('../../../../lib/infer');
var indexes = require('../../lib/indexes');
var glob = require('glob');
var path = require('path');
var ASTUtil = require('../../lib/ASTUtil');
var visibility = require('../../lib/visibility');
var FileUtil = require('../../lib/FileUtil');

require('../../../ext');

global.tern.unitTest = true;

var ecma5 = JSON.parse(fs.readFileSync(resolve.sync("../../../../defs/ecma5.json")), "utf8"),
    ecma6 = JSON.parse(fs.readFileSync(resolve.sync("../../../../defs/ecma6.json")), "utf8"),
    browser = JSON.parse(fs.readFileSync(resolve.sync("../../../../defs/browser.json")), "utf8");

var server,
    testRoot = path.join(process.cwd(), 'plugin', 'ext');

/**
 * Finds the caret position in a file and returns a file object
 * @param {String} file The file to parse
 * @returns an object with keys file and pos
 */
function parseFile(file, caretName) {
    var text = fs.readFileSync(file, 'utf8');
    var caretText = '/* ' + caretName + ' */';
    var carets = [];
    var pos;

    while ((pos = text.indexOf(caretText)) != -1) {
        carets.push(pos);
        text = text.replace(caretText, '');
    }

    var result = {
        file: {
            type: 'full',
            name: file,
            text: text
        },
        carets: carets
    };

    return result;
}

/**
 * Calls the specified callback for each occurence of the specified caret in the testDir
 * @param {String} caretName The caret to search for
 * @param {Function} callback A callback that takes an array of files, the index of the file containing the caret,
 *  and the position of the caret in the file
 */
function forEachCaret(caretName, callback) {
    var caretFiles = [],
        files = listFiles(caretName, caretFiles);

    caretFiles.forEach(function(file) {
        file.carets.forEach(function(caret) {
            callback(files, file.index, caret);
        })
    });
}

/**
 * Returns file objects for all files in the specified test directory
 * @param {String} caretName A caret to look for
 * @param {Object[]} caretFiles An array to add any files containing the specified caret
 * @return {Object[]}
 */
function listFiles(caretName, caretFiles) {
    var files = glob.sync(path.join(testRoot, 'test', 'resources', 'shared', '**', '*.js'))
        .concat(_.flatten(server._ExtJS.config.include.map(function(p) {
            return glob.sync(path.join(p, '**', '*.js'))
        })))
        .map(function(file, i) {
            file = path.resolve(file);
            var result = parseFile(file, caretName);
            result.index = i;
            if (result.carets.length) caretFiles.push(result);
            return result.file;
        });

    if (caretFiles.length === 0) throw new Error('Caret "' + caretName + '" not found in any of the test files.');

    return files;
}

/**
 * A collection of helper methods for unit testing
 */
var TestUtil = {
    /**
     * The server in which tests are run.  This is rebuilt before each test
     */
    server: undefined,

    /**
     * Properties from JavaScript's native Object class that should be suggested when completing any object
     */
    baseObjectProps: [
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
    ],

    /**
     * Properties from JavaScript's native Function class that should be suggested when completing static properties on a class
     */
    baseFunctionProps: [
        "apply",
        "call",
        "bind",
        "prototype"
    ],

    /**
     * Creates a TernJS server
     * @returns {exports.Server}
     */
    createServer: function() {
        // default config from bin/tern.js
        var config = {
            libs: [],
            defs: [ecma5, ecma6, browser],
            loadEagerly: false,
            plugins: {
                ext: {}
            },
            ecmaScript: true
        };

        return new tern.Server(config);
    },

    /**
     * Recreates the server.  This should be called before each test
     * @param {String} testDir relative path to the test directory from plugin/ext/test/resources
     */
    reset: function(testDir) {
        testDir = path.join(testRoot, "test", "resources", testDir);

        try {
            process.chdir(testDir);
            FileUtil.ensureSenchaDirs(testDir);
        } catch (e) {
            throw "Could not change directory to " + testDir;
        }

        delete global.tern.aliasScope;
        server = TestUtil.server = TestUtil.createServer();
    },

    /**
     * Removes the index data directory
     */
    cleanup: function() {
        var dir = path.join(process.cwd(), '.sencha-ide');
        fs.removeSync(dir);
        for (var key in indexes) indexes[key].clear()
    },

    /**
     * Parses a file into an AST
     * @param file
     */
    parse: function(file) {
        var code = fs.readFileSync(file, 'utf-8');
        code = code.replace('<caret>', '');
        return acorn.parse(code);
    },

    typeOf: function(file, callback) {
        var result = parseFile(file);
        var request = {
            files: [result.file],
            query: {
                type: 'type',
                file: '#0',
                end: result.pos
            }
        };

        server.request(request, function (err, data) {
            callback(data.type);
        });
    },

    /**
     * Asserts the returned document url
     * @param {String} testDir a file path relative to the project root where test js files are located.
     * @param {String} caretName The name of the caret to use - will search for a block comment containing this string to determine where completions should be done.
     * @param {String} expected SDK specific url for classname, config, property, method, static method or event
     */
    assertDocs: function(testDir, caretName, expected) {
        TestUtil.reset(testDir);
        forEachCaret(caretName, function(files, caretFileIndex, caretPos) {
           var request = {
               files: files,
               query: {
                   type: "documentation",
                   file: '#' + caretFileIndex,
                   end: caretPos,
                   origins:true
               }
           };

            server.request(request, function(err, data) {
                if(err) throw err;
                var actual = data.url;
                actual.should.equal(expected);
            });


        });
    },

    assertTypes: function(testDir, caretName, expected) {
        TestUtil.reset(testDir);
        forEachCaret(caretName, function(files, caretFileIndex, caretPos) {
            server.reset();

            var request = {
                files: files,
                query: {
                    type: "type",
                    file: '#' + caretFileIndex,
                    end: caretPos
                }
            };

            server.request(request, function (err, data) {
                if (err) throw err;
                data.should.deep.equal(expected);
            });
        });

    },

    /**
     * Asserts that only the specified completions are returned.
     * @param {String} testDir a file path relative to the project root where test js files are located.
     * @param {String} caretName The name of the caret to use - will search for a block comment containing this string to determine where completions should be done.
     * @param {String[]} expected An array of the expected completion suggestions.  The array may contain nested arrays which will be flattened automatically
     */
    assertCompletions: function(testDir, caretName, expected) {
        expected = _.flatten(expected);
        TestUtil.reset(testDir);

        forEachCaret(caretName, function(files, caretFileIndex, caretPos) {
            var request = {
                files: files,
                query: {
                    type: "completions",
                    file: '#' + caretFileIndex,
                    end: caretPos,
                    types: true,
                    includeKeywords: true,
                    sort: true,
                    guess: true,
                    docs: true,
                    urls: true,
                    origins: true,
                    lineCharPositions: true,
                    caseInsensitive: true
                }
            };

            server.request(request, function (err, data) {
                if (err) throw err;
                var actual = data.completions;

                // TODO figure out why we are getting duplicates for each caret
                // expected.length.should.equal(actual.length);

                Object.keys(infer.cx().protos.Object.props).forEach(function(k) { delete actual[k] });

                var suggestions = [];

                actual.forEach(function(suggestion) {
                    suggestions.push(suggestion.insertionText || suggestion.name);
                });

                expected.sort().should.have.same.members(suggestions.sort())
            });
        });
    },

    /**
     * Asserts that the element referenced at the caret position is defined in the specified location in code
     * @param {String} testDir The relative path to the test directory
     * @param {String} caretName The name of the caret marking the referencing element
     * @param {String} origin The expected file in which the member is declared
     * @param {String} startName The name of the caret marking the start of the definition element in the origin file
     */
    assertDefinedAt: function(testDir, caretName, origin, startName) {
        TestUtil.reset(testDir);
        origin = path.join(origin);

        var caretComment = '/* ' + startName + ' */',
            file = { text: fs.readFileSync(origin, 'utf8') };

        forEachCaret(caretName, function(files, caretFileIndex, caretPos) {
            var request = {
                files: files,
                lineCharPositions: false,
                query: {
                    type: "definition",
                    file: '#' + caretFileIndex,
                    end: caretPos
                }
            };

            var expectedStart = file.text.indexOf(caretComment) + caretComment.length;

            // test offset
            server.request(request, function (err, results) {
                if (err) throw err;
                var data = results[0];
                data.origin.should.equal(path.join(process.cwd(), origin));
                data.start.should.equal(expectedStart);
            });

            // test line/ch position
            request.query.lineCharPositions = true;
            expectedStart = tern.outputPos(request.query, file, expectedStart);

            server.request(request, function (err, results) {
                if (err) throw err;
                var data = results[0];
                data.origin.should.equal(path.join(process.cwd(), origin));
                data.start.line.should.equal(expectedStart.line);
                data.start.ch.should.equal(expectedStart.ch);
            });
        });
    },

    /**
     * Calls the specified call back for each occurrence of the specified caret
     * @param {String} testDir The relative path to the test directory
     * @param {String} caretName The name of the caret marking the referencing element
     * @param {Function} callback A function to call which is passed the element at the caret position
     */
    assertAtCaret: function(testDir, caretName, callback) {
        TestUtil.reset(testDir);

        forEachCaret(caretName, function(files, caretFileIndex, caretPos) {
            infer.withContext(server.cx, function() {
                var file = files[caretFileIndex].name,
                    ast = ASTUtil.parse(file),
                    found = infer.findExpressionAround(ast, null, caretPos);

                if (found) {
                    visibility.setContext(file);
                    callback(found.node);
                } else {
                    throw new Error("Caret " + caretName + " could not be found in " + file);
                }
            });
        })
    },
};

module.exports = TestUtil;