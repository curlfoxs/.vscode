"use strict";

var TestUtil = require('./../lib/test_util');
var chai = require('./../lib/chai_setup');
var _ = require('lodash');

describe('Code completion', function() {
    afterEach(TestUtil.cleanup); // rebuild the server before each test so that test classes don't bleed over between tests

    it('should complete expected configs', function() {
        TestUtil.assertCompletions('completion/general', 'configs', [
            'configFromTagMixin',
            'configFromOverride',
            'configFromBaseMixin1',
            'configFromBaseMixin2',
            'baseConfigFromComment',
            'baseConfigFromProperty',
            'configFromChildMixin1',
            'configFromChildMixin2',
            'childConfigFromComment',
            'childConfigFromProperty'
        ]);
    });

    it('should complete expected properties', function() {
        TestUtil.assertCompletions('completion/general', 'properties', [
            TestUtil.baseObjectProps,
            "baseMethod",
            "baseProperty",
            "childMethod",
            "childProperty",
            "getBaseConfigFromProperty",
            "getChildConfigFromProperty",
            "getConfigFromOverride",
            "methodFromBaseMixin1",
            "methodFromBaseMixin2",
            "methodFromChildMixin1",
            "methodFromChildMixin2",
            "methodFromOverride",
            "propertyFromBaseMixin1",
            "propertyFromBaseMixin2",
            "propertyFromChildMixin1",
            "propertyFromChildMixin2",
            "propertyFromOverride",
            "propertyIsEnumerable",
            "setBaseConfigFromProperty",
            "setChildConfigFromProperty",
            "setConfigFromOverride"
        ]);
    });

    it('should complete xtypes', function() {
        TestUtil.assertCompletions('completion/xtypes', 'caret', [
            'fromalias',
            'fromxtype',
            'fromarray',
            'array'
        ]);

        TestUtil.assertCompletions('completion/xtypes', 'unquoted', [
            "'fromalias'",
            "'fromxtype'",
            "'fromarray'",
            "'array'"
        ]);
    });

    it('should parse config comments not attached to expressions', function() {
        TestUtil.assertCompletions('completion/comments', 'configs', [
            'c1',
            'c2',
            'c3'
        ]);
    });

    it('should parse member comments not attached to expression', function() {
        TestUtil.assertCompletions('completion/comments', 'members', [
            TestUtil.baseObjectProps,
            'p1',
            'p2',
            'm1',
            'm2',
            'getC3',
            'setC3'
        ]);
    });

    it('should skip inline comments', function() {
        TestUtil.assertCompletions('completion/inlineComments', 'caret', [
            TestUtil.baseObjectProps,
            'm1',
            'm2'
        ]);
    });

    it('should handle tags without names', function() {
        TestUtil.assertCompletions('completion/tagsWithoutNames', 'configs', [
            'testConfig'
        ]);
        TestUtil.assertCompletions('completion/tagsWithoutNames', 'properties', [
            TestUtil.baseObjectProps,
            'testProperty'
        ]);
    });

    it('should propagate this in methods', function() {
        TestUtil.assertCompletions('completion/propagateThis', 'noComment', [
            TestUtil.baseObjectProps,
            'testMethod1',
            'testMethod2',
            'testProperty'
        ]);

        TestUtil.assertCompletions('completion/propagateThis', 'comment', [
            TestUtil.baseObjectProps,
            'testMethod1',
            'testMethod2',
            'testProperty'
        ]);
    });

    it('should extract class metadata from comments', function() {
        TestUtil.assertCompletions('completion/classFromComments', 'properties', [
            TestUtil.baseObjectProps,
            'm1',
            'm2',
            'm3',
            'p1',
            'p2'
        ]);
    });

    it('should complete statics', function() {
        TestUtil.assertCompletions('completion/statics', 'caret', [
            TestUtil.baseFunctionProps,
            'baseMethod',
            'baseMethodInStaticBlock',
            'fromProperty',
            'fromComment',
            'fromAssignment'
        ]);
    });

    it('should complete configs for an object with an xtype', function() {
        TestUtil.assertCompletions('completion/objectWithXType', 'caret', [
            'xclass',
            'c1',
            'c2'
        ]);
    });

    it('should resolve alternateClassNames', function() {
        TestUtil.assertCompletions('completion/alternateClassName', 'single', [
            TestUtil.baseObjectProps,
            'testSingle1',
            'testSingle2'
        ]);
        TestUtil.assertCompletions('completion/alternateClassName', 'multi', [
            TestUtil.baseObjectProps,
            'testMulti1',
            'testMulti2'
        ]);
    });

    it('should complete events in listeners', function() {
        TestUtil.assertCompletions('completion/listeners', 'caret', [
            'event1',
            'event2'
        ]);
        TestUtil.assertCompletions('completion/listeners', 'unquoted', [
            "'event1'",
            "'event2'"
        ]);
    });

    it('should add members from overrides', function() {
        TestUtil.assertCompletions('completion/overrides', 'properties', [
            TestUtil.baseObjectProps,
            'method',
            'property',
            'overriddenProperty',
            'overriddenMethod',
        ]);
        TestUtil.assertCompletions('completion/overrides', 'configs', [
            'config',
            'memberConfig'
        ]);
        TestUtil.assertCompletions('completion/overrides', 'events', [
            'overrideevent'
        ]);
    });

    it('should complete configs inside config block', function() {
        TestUtil.assertCompletions('completion/configBlock', 'caret', [
            'config1',
            'config2'
        ]);
    });

    it('should extract members from prototypes', function() {
        TestUtil.assertCompletions('completion/prototype', 'configs', [
            'aliasPrefix'
        ]);

        TestUtil.assertCompletions('completion/prototype', 'properties', [
            TestUtil.baseObjectProps,
            'create',
            'define'
        ]);
    });

    it('should handle classes that are also namespaces', function() {
        TestUtil.assertCompletions('completion/classAndNamespace', 'caret', [
            TestUtil.baseObjectProps,
            'method'
        ]);
    });

    it('should handle Ext.define with a function', function() {
        TestUtil.assertCompletions('completion/defineWithFunction', 'properties', [
            TestUtil.baseObjectProps,
            'findParentNode'
        ]);
    });

    it('should assume properties with @param or @return are methods', function() {
        TestUtil.assertCompletions('completion/ambiguousPropertyWithParam', 'caret', [
            TestUtil.baseObjectProps,
            'methodWithParam',
            'methodWithReturn',
            'id'
        ]);
    });

    it('should infer cfg names from inheritdoc', function() {
        TestUtil.assertCompletions('completion/inheritdoc', 'configs', [
            'api'
        ]);
    });

    it('should process Ext namespace without exceeding call stack', function() {
        TestUtil.assertCompletions('completion/ext', 'caret', [
            TestUtil.baseObjectProps,
            TestUtil.baseFunctionProps,
            'ClassManager',
            'create',
            'createByAlias',
            'define',
            'widget',
            'checkVersion',
            'enableFx',
            'Anim',
            'Base'
        ]);
    });

    it('should completion configs for Ext.data.Field', function() {
        TestUtil.assertCompletions('completion/fieldConfigs', 'caret', [
            'xclass',
            'type',
            'name',
            'persist'
        ]);
    })

    it('should complete configs based on type', function() {
        TestUtil.assertCompletions('completion/configsByType', 'caret', [
            'xclass',
            'type',
            'name',
            'persist',
            'intValue'
        ]);
    });

    it('should complete type values', function() {
        TestUtil.assertCompletions('completion/typeValues', 'caret', [
            'integer',
            'auto'
        ]);
    });

    it('should include the typeProperty when completing configs', function() {
        TestUtil.assertCompletions('completion/typeProperty', 'component', [
            'xclass',
            'xtype'
        ]);

        TestUtil.assertCompletions('completion/typeProperty', 'layout', [
            'xclass',
            'type'
        ]);
    });

    it('should include protected template methods when completing class configs', function() {
        TestUtil.assertCompletions('completion/templateMethods', 'class', [
            'initComponent'
        ]);
    });

    it('should not include protected template methods when completing instance configs', function() {
        TestUtil.assertCompletions('completion/templateMethods', 'instance', []);
    });

    it('should complete properties for Ext.widget', function() {
        TestUtil.assertCompletions('completion/Ext.widget', 'caret', [
            TestUtil.baseObjectProps,
            'myMethod'
        ]);
    });

    it('should complete configs for Ext.widget', function() {
        TestUtil.assertCompletions('completion/Ext.widget-configs', 'caret', [
            'myConfig'
        ]);
    });

    it('should complete configs for Ext.createByAlias', function() {
        TestUtil.assertCompletions('completion/Ext.createByAlias-configs', 'caret', [
            'myConfig'
        ]);
    });

    it('should complete properties for Ext.createByAlias', function() {
        TestUtil.assertCompletions('completion/Ext.createByAlias', 'caret', [
            TestUtil.baseObjectProps,
            'myMethod'
        ]);
    });

    it('should include xclass when completing configs in object literals where class is unknown', function() {
        TestUtil.assertCompletions('completion/xclass', 'caret', [
            'xclass',
            'xtype'
        ]);
    });

    it('should only include aliases from the same toolkit', function() {
        TestUtil.assertCompletions('completion/aliasesInToolkit', 'classic', [
            'desktoppanel'
        ]);
        TestUtil.assertCompletions('completion/aliasesInToolkit', 'modern', [
            'mobilepanel'
        ]);
    });

    it('should complete controller methods in the class hierarchy', function(){
        TestUtil.assertCompletions('completion/controller/methodsInClassHierarchy', 'caret', [
            'myMethod1',
            'myMethod2'
        ]);
    });

    it('should complete controller methods from the component tree', function(){
        TestUtil.assertCompletions('completion/controller/methodsInComponentTree', 'caret', [
            'myMethod1',
            'myMethod2'
        ])
    });

    it('should complete controller methods from the parent component', function(){
        TestUtil.assertCompletions('completion/controller/methodsInParentComponent', 'caret', [
            'myMethod1',
            'myMethod2'
        ])
    });

    it('should complete controller methods from the controller hierarchy', function(){
        TestUtil.assertCompletions('completion/controller/methodsInControllerHierarchy', 'caret', [
            'myMethod1',
            'myMethod2',
            'myBaseMethod1',
            'myBaseMethod2'
        ])
    });

    it('should not complete methods from sdk classes', function(){
        TestUtil.assertCompletions('completion/controller/methodsNotFromSDK', 'caret', [
            'myMethod1',
            'myMethod2'
        ])
    });


    it('should complete bound values from view models', function() {
        TestUtil.assertCompletions('completion/boundValues', 'caret', [
            'value1',
            'value2',
            'store1',
            'store2',
            'model1',
            'model2'
        ]);
    });

    it('should complete in files outside of process.cwd()', function() {
        TestUtil.assertCompletions('completion/config.paths/project', 'caret', [
            TestUtil.baseObjectProps,
            'myMethod'
        ]);
    });

    it('should add insertion text for unquoted literal suggestions', function() {
        TestUtil.assertCompletions('completion/unquoted', 'caret', [
            "'widget1'",
            "'widget2'"
        ]);
    });

    it('should handle Ext.create({ xtype: ... })', function() {
        TestUtil.assertCompletions('completion/Ext.create-config', 'caret', [
            TestUtil.baseObjectProps,
            "myMethod"
        ]);
    });

    it('should complete configs in Ext.createByAlias', function() {
        TestUtil.assertCompletions('completion/Ext.createByAlias-configs', 'caret', [
            "myConfig"
        ]);
    });

    it('should complete configs in Ext.widget', function() {
        TestUtil.assertCompletions('completion/Ext.widget-configs', 'caret', [
            "myConfig"
        ]);
    });

    it('should complete mvc references', function() {
        TestUtil.assertCompletions('completion/mvc', 'caret', [
            "User",
            "admin"
        ]);
    });

    it('should complete store configs in ViewModels', function() {
        TestUtil.assertCompletions('completion/storeConfigsInViewModel', 'caret', [
            "model",
            "proxy",
            "type",
            "xclass"
        ]);
    });

    it('should complete configs in bind object', function() {
        TestUtil.assertCompletions('completion/bindObject', 'caret', [
            "config1",
            "config2"
        ]);
    });

    it('should include aliases when completing Ext.create', function() {
        TestUtil.assertCompletions('completion/Ext.create-aliases', 'base', [
            "View",
            "Ext",
            "widget"
        ]);

        TestUtil.assertCompletions('completion/Ext.create-aliases', 'widget', [
            "view"
        ]);
    });

    it('should complete model types', function() {
        TestUtil.assertCompletions('completion/modelTypesInViewModelStores', 'caret', [
            "Role",
            "User"
        ]);
    });

    it('should not include classes when completing Ext.define', function() {
        TestUtil.assertCompletions('completion/Ext.define', 'caret', [
            "user"
        ]);
    });

    it('should handle directRefs', function() {
        TestUtil.assertCompletions('completion/directRef', 'caret', [
            "items",
            "xclass"
        ]);
    });

    it('should exclude aliases for controllers in the sdk', function() {
        TestUtil.assertCompletions('completion/controllerAliases', 'caret', [
            "app"
        ]);
    });

    it('should complete toolkit classes in single-toolkit app', function() {
        TestUtil.assertCompletions('completion/singleToolkit', 'caret', [
            "config1",
            "config2"
        ]);
    });

    it('should not include the current token when completing configs', function() {
        TestUtil.assertCompletions('completion/config-hideCurrentToken', 'caret', [
            "baseConfig"
        ]);
    });

    it('should parse Ext.feature correctly', function() {
        TestUtil.assertCompletions('completion/Ext.feature', 'caret', [
            TestUtil.baseObjectProps,
            "has",
            "tests"
        ]);
    });

    it('should extract members from classes composed in an ad hoc manner', function() {
        TestUtil.assertCompletions('completion/adHoc', 'caret', [
            TestUtil.baseObjectProps,
            'formatCodes'
        ]);
    });

    it('should add events for configs in eventedConfig', function() {
        TestUtil.assertCompletions('completion/eventedConfig', 'caret', [
            'widthchange'
        ]);
    });

    it('should add events for configs with @evented', function() {
        TestUtil.assertCompletions('completion/eventedTag', 'caret', [
            'maxwidthchange'
        ]);
    });

    it('should index Ext.Msg correctly', function() {
        TestUtil.assertCompletions('completion/Ext.Msg', 'caret', [
            TestUtil.baseObjectProps,
            'alert',
            'confirm'
        ]);
    });

    it('should not include excluded files', function() {
        TestUtil.assertCompletions('completion/exclude', 'caret', [
            'Included'
        ]);
    });

    it('should only include namespaces from the same toolkit', function() {
        TestUtil.assertCompletions('completion/namespacesInToolkit', 'modern', [
            'modern'
        ]);
        TestUtil.assertCompletions('completion/namespacesInToolkit', 'classic', [
            'classic'
        ]);
    });

    it('should not show private classes outside of the file where the class is defined.', function() {
        TestUtil.assertCompletions('completion/privateClasses', 'public', [
            'PublicClass'
        ]);
        TestUtil.assertCompletions('completion/privateClasses', 'private', [
            'PublicClass',
            'PrivateClass'
        ]);
    });

    it('should complete field names from a store by id', function() {
        TestUtil.assertCompletions('completion/storeFields.id', 'caret', [
            'name',
            'email'
        ]);
    });

    it('should complete field names from a store by short name', function() {
        TestUtil.assertCompletions('completion/storeFields.shortName', 'caret', [
            'name',
            'email'
        ]);
    });

    it('should complete field names from the bound store model', function() {
        TestUtil.assertCompletions('completion/modelFields', 'caret', [
            'name',
            'email'
        ]);
    });

    it('should complete field names from the bound store', function() {
        TestUtil.assertCompletions('completion/storeFields', 'caret', [
            'name',
            'email'
        ]);
    });

    it('should complete store ids', function() {
        TestUtil.assertCompletions('completion/storeIds', 'caret', [
            'Users',
            'roles'
        ]);
    });

    it('should complete store types', function() {
        TestUtil.assertCompletions('completion/storeTypes', 'caret', [
            'users',
            'roles'
        ]);
    });

    it('should get config type from property of same name', function() {
        TestUtil.assertCompletions('completion/propertyOfSameName', 'caret', [
            'namespace',
            'xclass'
        ]);
    });

    it('should complete members properties with multiple types', function() {
        TestUtil.assertCompletions('completion/multipleTypes', 'method', [
            TestUtil.baseObjectProps,
            'foo1',
            'foo2',
            'bar1',
            'bar2'
        ]);
        TestUtil.assertCompletions('completion/multipleTypes', 'property', [
            TestUtil.baseObjectProps,
            'foo1',
            'foo2',
            'bar1',
            'bar2'
        ]);
    });

    it('should assign the correct type for Ext.app.ViewController#getView', function() {
        TestUtil.assertCompletions('completion/getView', 'caret', [
            TestUtil.baseObjectProps,
            'controller',
            'method1',
            'method2'
        ]);
    });

    it('should return the correct references from Ext.app.ViewController#lookupReference', function() {
       TestUtil.assertCompletions('completion/lookupReference/viewRefs', 'caret', [
           'myButton',
           'myPanel'
       ]);
    });

    it('should return the correct references from Ext.app.ViewController#lookup', function() {
        TestUtil.assertCompletions('completion/lookupReference/lookup', 'caret', [
            'myButton',
            'myPanel'
        ]);
    });

    it('should return the members for a given reference from Ext.app.ViewController#lookupReference', function() {
        TestUtil.assertCompletions('completion/lookupReference/refMembers', 'caret', [
            TestUtil.baseObjectProps,
            'click',
            'toggle',
            'getArrowVisible',
            'setArrowVisible'
        ]);
    });

    it('should add members using Ext.apply', function() {
        TestUtil.assertCompletions('completion/Ext.apply', 'caret', [
            TestUtil.baseObjectProps,
            "applyIf",
            "ClassManager",
            "create",
            "createByAlias",
            "define",
            "widget"
        ]);
    });

    it('should handle classes created via assignment', function() {
        TestUtil.assertCompletions('completion/classFromAssignment', 'caret', [
            TestUtil.baseObjectProps,
            "id",
            "delay"
        ]);
    });

    it('should correctly index Ext.String#format', function() {
        TestUtil.assertCompletions('completion/Ext.String.format', 'caret', [
            TestUtil.baseObjectProps,
            "format"
        ]);
    });

    it('should only classify members as static if they are properties of a static block or have @static', function() {
        TestUtil.assertCompletions('completion/instanceInStatic', 'caret', [
            TestUtil.baseObjectProps,
            "appendChild"
        ]);
    });

    it('should parse Ext.form.field.VTypes correctly', function() {
        TestUtil.assertCompletions('completion/Ext.form.field.VTypes', 'caret', [
            TestUtil.baseObjectProps,
            "alpha"
        ]);
    });

    it('should assign events to the class specified in the @member tag', function() {
        TestUtil.assertCompletions('completion/eventsWithMemberTag', 'caret', [
            "beforeselectionextend"
        ]);
    });

    it('should add accessors for configs with @accessor', function() {
        TestUtil.assertCompletions('completion/accessorTag', 'caret', [
            TestUtil.baseObjectProps,
            "setName",
            "getName"
        ]);
    });

    it('should parse comments in files without nodes', function() {
        TestUtil.assertCompletions('completion/noNodes', 'caret', [
            TestUtil.baseObjectProps,
            "beforeRender"
        ]);
    });

    it('should parse comments at the AST root', function() {
        TestUtil.assertCompletions('completion/commentsAtRoot', 'caret', [
            "Viewport"
        ]);
    })

    it('should skip classes with ignore tag', function() {
        TestUtil.assertCompletions('completion/ignore/classes', 'caret', [
            "ClassManager",
            "Panel",
            "Button2"
        ]);
    })

    it('should skip configs with ignore tag', function() {
        TestUtil.assertCompletions('completion/ignore/configs', 'caret', [
            'title',
            'animCollapse'
        ]);
    });

    it('should skip minified files', function() {
        TestUtil.assertCompletions('completion/minified', 'caret', [
            'Ext',
            'Source'
        ]);
    });

    it('should complete class names in string literals', function() {
        TestUtil.assertCompletions('completion/strings', 'caret', [
            'Foo'
        ]);
    });

    it('should index sdks outside of the project root', function() {
        TestUtil.assertCompletions('completion/externalSdks/App', 'caret', [
            'bar'
        ]);
    })
});
