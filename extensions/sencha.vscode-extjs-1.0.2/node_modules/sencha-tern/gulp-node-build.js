var gulp = require('gulp'),
    _ = require('lodash'),
    uglify = require('gulp-uglify'),
    sourcemaps = require('gulp-sourcemaps'),
    replace = require('gulp-replace'),
    fs = require('fs-extra'),
    SourceMapConsumer = require('source-map').SourceMapConsumer,
    async = require('async'),
    exec = require('child_process').exec,
    http = require('http'),
    version = require('./plugin/ext/lib/version'),
    glob = require('glob'),
    request = require('request');

/**
 * Downloads a file unless it already exists and calls the specified callback when done.
 * @param url
 * @param file
 * @param callback
 */
function download(url, file, callback) {
    if (!fs.existsSync(file)) {
        console.log('downloading ' + url);
        fs.mkdirsSync(file.replace(/\/[^\/]*$/, ''));

        http.get(url, response => {
            var stream = fs.createWriteStream(file);
            response.pipe(stream);
            stream.on('finish', callback);
        })
    } else {
        callback();
    }
}

/**
 * Creates a package tag.gz file with node and the tern app
 * @param name The name of the package
 * @param nodeBinary The path to the node.js binary
 */
function createPackage(name, nodeBinary, callback) {
    var dest = `dist/${name}`;
    fs.mkdirsSync(`dist/${name}`);

    async.series([
            callback => gulp.src('dist/tern/**', {base: 'dist'}).pipe(gulp.dest(dest)).on('end', callback),
            callback => gulp.src(nodeBinary).pipe(gulp.dest(dest)).on('end', callback)
    ], () => {
        exec(`cd ${dest} && tar czf ../tern-${name}-${version}.tar.gz * `, callback);
    });
}

/**
 * Uglifies the source code and creates source maps
 */
gulp.task('build', ['clean'], function(callback) {
    fs.mkdirsSync('dist');

    async.series([
            callback => gulp.src(['bin/**/*.js', 'lib/**/*.js', 'plugin/*.js', 'plugin/ext/lib/*.js'], { base: '.' })
            .pipe(sourcemaps.init())
            .pipe(uglify())
            .pipe(sourcemaps.write('../maps'))
            .pipe(gulp.dest('dist'))
            .on('end', callback),

            callback => gulp.src(['node_modules/**', 'defs/**'], {base: '.'})
            .pipe(gulp.dest(`dist`))
            .on('end', callback)
    ], callback)
});

/**
 * Creates native packages for Mac OS and Windows
 */
gulp.task('package', ['build'], function(callback) {
    async.series([
            callback => download(`http://nodejs.org/dist/v${nodeVersion}/win-x64/node.exe`, 'node_binaries/win-x64/node.exe', callback),
            callback => download(`http://nodejs.org/dist/v${nodeVersion}/win-x86/node.exe`, 'node_binaries/win-x86/node.exe', callback),
            callback => download(`http://nodejs.org/dist/v${nodeVersion}/node-v${nodeVersion}-darwin-x64.tar.gz`, 'node_binaries/darwin-x64.tar.gz', callback),
            callback => exec('cd node_binaries && tar xzf darwin-x64.tar.gz', callback),
            callback => gulp.src(`node_binaries/node-v${nodeVersion}-darwin-x64/bin/node`).pipe(gulp.dest('dist/node/darwin-x64')).on('end', callback),
            callback => gulp.src('node_binaries/win-x64/node.exe').pipe(gulp.dest('dist/node/win-x64')).on('end', callback),
            callback => gulp.src('node_binaries/win-x86/node.exe').pipe(gulp.dest('dist/node/win-x86')).on('end', callback),
            callback => exec(`cd dist && zip -qr tern-${version}.zip * `, callback),
            callback => fs.writeFile('dist/tern.version', version, callback),
    ], err => {
        if (err) console.log('error', err);
        callback();
    });
});

gulp.task('package-dev', ['package'], function() {
    var targetDir = props['dev.build.target'];

    // clean up old builds
    glob.sync(`${targetDir}/tern-*.zip`).forEach(file => fs.unlinkSync(file));

    // copy over new build
    var devVersion = `${version}.${new Date().getTime()}`;
    fs.copySync(`dist/tern-${version}.zip`, `${targetDir}/tern.zip`, { clobber: true });

    // write the version number to tern.version so the plugin knows the name of the file in the bundle
    fs.writeFileSync(`${targetDir}/tern.version`, devVersion);
});

/**
 * The length of the function wrapper prefix that node applies to each module.  This is the offset by which the column number is
 * off in node 4.0.0.  This issue is documented here:
 * https://github.com/nodejs/node/issues/2860
 * ...and potentially fixed here: https://github.com/nodejs/node/pull/2867
 * @type {number}
 */
const NODE_WRAPPER_FN_LENGTH = 62;

function toStackTrace(frames) {
    return frames.map(function(frame) {
        if (!frame.filename) frame.filename = frame.fileName;
        if (!frame.lineno) frame.lineno = frame.lineNumber;
        if (!frame.colno) frame.colno = frame.columnNumber;

        var mapFile = frame.filename.replace(/^.*\/tern\//, './maps/') + '.map';

        if (fs.existsSync(mapFile)) {
            var rawSourceMap = JSON.parse(fs.readFileSync(mapFile));
            var smc = new SourceMapConsumer(rawSourceMap);
            frame = Object.assign(frame, smc.originalPositionFor({ line: frame.lineno, column: frame.colno-NODE_WRAPPER_FN_LENGTH }));
            var content = smc.sourceContentFor(frame.source, true);
            if (content) frame.content = content ? content.split('\n')[frame.line-1] : '<unknown>';
            return `at ${frame.method} (${frame.source}:${frame.line}:${frame.column})`;
        } else {
            return `at ${frame.method} (${frame.fileName}:${frame.lineno}:${frame.colno})`;
        }
    }).reverse().join('\n');
}

gulp.task('convertStackTrace', function() {
    var occurrenceUrl = "https://rollbar.com/Sencha/Tern/items/5/occurrences/7612847019/";
    var rollbarToken = '7a5ac33d7f60483d96da3c92e5201608';
    var id = occurrenceUrl.replace(/\/$/, '').match(/[^\/]*$/);
    var url = `http://api.rollbar.com/api/1/instance/${id}?access_token=${rollbarToken}`

    request({url: url}, (error, response, body) => {
        var data = JSON.parse(body);
        var trace = toStackTrace(data.result.data.body.trace.frames)
        console.log(trace);
    });
});

