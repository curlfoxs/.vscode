ST.playable.define('State', {
    ready: function () {
        var me = this,
            is = me.is,
            wait = me.wait,
            args = me.args || [];

        if (!wait) {
            if (this.animationsDone() && this.targetReady()) {
                if (!is.apply(me, args)) {
                    return this.setWaiting(me.type, 'true');
                }
                return this.setWaiting(false);
            }
            return false;
        } else {
            return true;
        }
    },

    fn: function (done) {
        var me = this,
            is = me.is,
            wait = me.wait,
            args = me.args || [],
            eventName, i, fn;

        if (wait) {
            // Set up wait() for string/array of defined event names
            if (typeof wait !== 'function') {
                eventName = (typeof wait === 'string') ? [wait] : wait;

                wait = function (done) { // TODO clarify the done and it's scope by using different names? done, waitdone, fndone???
                    var me = this,
                        cmp = me.getComponent(),
                        listener = {},
                        fn, timer;

                    fn = function () {
                        if (is.apply(me, args)) {
                            if (timer) {
                                ST.deferCancel(timer);
                            }

                            cmp.un(listener);
                            done();
                            done = ST.emptyFn;
                        } else if (!timer) {
                            timer = ST.defer(function () {
                                timer = null;

                                if (is.apply(me, args)) {
                                    cmp.un(listener);
                                    done();
                                    done = ST.emptyFn;
                                }
                            }, 0);
                        }
                    }

                    for (i = 0; i < eventName.length; i++) {
                        listener[eventName[i]] = fn;
                    }

                    cmp.on(listener);

                    return function () {
                        cmp.un(listener);
                    };
                };
            }

            fn = function () {
                if (ST.LOGME) console.log('State, fn = function, this.timeout='+this.timeout);

                // debugger

                var me = this,
                    timeout = me.timeout;


                // With a wait() we can just schedule in a call to advance
                // instead of polling the is() method.
                var event = this,
                    args = ST.Array.slice(arguments), // TODO just for the unwait bit down below...
                    timer, unwait;

                if (is.apply(me, args)) {
                    done();
                } else {
                    event.setWaiting(me.type, 'true');

                    args.unshift(function () { // the done function to use later in unwait...
                        if (timer) {
                            timer = timer(); // call cancelFn
                            event.setWaiting(false);
                            done();
                        }
                    });

                    unwait = wait.apply(me, args);

                    timer = ST.timeout(function () {
                        timer = 0;
                        unwait();
                        done({
                            timeout: true
                        });
                        // event._player.doTimeout(event); // _player still there??? NOT FOR REMOTE!!!
                    }, timeout);
                }
            };
            return fn.call(me);
        } else {
            done();
        }
    }
});
