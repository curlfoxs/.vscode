/**
 * @class ST.future.Element
 * A future Element is a class that can be used to interact with an element that will
 * exist at some point. Typically that element does not exist when the future is created.
 *
 * The methods of a future (including its constructor) defer actions in an event queue
 * (based on {@link ST.event.Player}). A simple example would be:
 *
 *      ST.element('@some-div').
 *          click(10, 10);
 *
 * The API of futures is based on chained method calls, sometimes called a "fluent"
 * API. In the above example, the `{@link ST#element}` method accepts the locator and
 * returns a future. The `{@link #tap}` method of the future queues a click
 * event at offset (10, 10).
 *
 * ## Actions
 * Many methods of futures perform actions (such as `click`) on their target. These
 * methods schedule their actions so that they follow previously invoked future methods
 * to ensure that these actions flow in the same order as the test code that requested
 * them.
 *
 * Actions methods use verbs for names.
 *
 * ## States
 * The other main group of methods on futures are state methods. These methods do not
 * affect their target but rather schedule a delay in the test sequence that begins at
 * the proper time (following all previously schedules operations) and finishing when
 * the target arrives in the desired state.
 *
 * For example:
 *
 *      ST.element('@some-div').
 *          click(10, 10).
 *          textLike(/hello/i);
 *
 * The above test will locate our div, click on it and then wait for its `textContent`
 * to match the specified regular expression. The test will complete successfully if
 * the text matches within the default timeout (5 seconds) and will fail otherwise.
 *
 * State methods use nouns or descriptions for names.
 *
 * ## Inspections
 * Because operations on futures all complete asynchronously, it is important not to
 * mix these operations with immediate method calls. Instead, we schedule inspections
 * using the future's `{@link #and}` method.
 *
 *      ST.element('@some-div').
 *          click(10, 10).
 *          and(
 *              // Invoked after the click has played. The ST.Element wrapper for
 *              // the target div is given as a parameter.
 *              function (divEl) {
 *                  expect(divEl.hasCls('foo')).toBe(false);
 *              }
 *          );
 *
 * The functions passed to `and()` are called "inspections" but there are no particular
 * restrictions on what these methods actually do when they are called.
 *
 * ## Waiting
 * There are two basic ways to control the timing of the test sequence. The first is the
 * `and()` method's optional second argument:
 *
 *      ST.element('@some-div').
 *          click(10, 10).
 *          and(function (divEl, done) {
 *              something().then(done);
 *          });
 *
 * When an inspection function is declared to have a second argument, it is called with
 * a completion function typically named "done". If declared as an argument, this function
 * must be called or the test will fail. The inspection function, however, can decide when
 * the function should be called. Once `done` is called, the test sequence can continue.
 *
 * When there is no mechanism that can reasonably be used to determine when a condition
 * is satisfied, there is the `{@link ST#wait}` method.
 *
 *      ST.element('@some-div').
 *          click(10, 10).
 *          wait(function (divEl) {
 *              return divEl.hasCls('foo');
 *          });
 *
 * In this case, the function passed to `wait()` is called periodically and when it
 * eventually returns `true` the test can proceed. Obviously, the `and()` method and its
 * `done` function are preferrable because they won't need to poll for completion. Which
 * approach is more readily implemented in a given situation will typically determine the
 * best choice, and not this slight performance consideration.
 *
 * ## Components
 *
 * When interacting with Ext JS components, see `{@link ST#component}` or one of the
 * more specific methods such as `{@link ST#panel}`, `{@link ST#grid}`, etc..
 *
 * ### Note
 *
 * This class is not created directly by user code. Instead, it is created automatically
 * by various helper methods, like {@link ST#element} and {@link ST#wait}.
 */
// NOTE we must ST.define Element instead of ST.future.define because it is
// the default base class so must exist? We could pass in body.extend =
// something else like ST._base???

ST.future.Element = ST.define({
    valueProperty: 'el',
    $className: 'ST.future.Element',
    $states: {},
    $futureType: 'element',
    $futureTypeChain: ['element'],
    $futureTypeMap: {
        element: true
    },
    statics: {
        /**
         * if config is a function, the playable will extend ST.playable.State and the
         * provided function will be the "is" function.
         */
        addPlayable: function (name, config) {
            var me = this,
                playableName = ST.capitalize(name),
                cls, addEvent;

            // save original config for inheritance
            me.prototype.$playables = me.prototype.$playables || {};
            me.prototype.$playables[name] = config;

            // if a function, then that fn is an "is"
            if (typeof config === 'function') {
                config = {
                    is: config
                }
            }

            if (config.is) {
                config.extend = config.extend || ST.playable.State;
            }

            if(!config.extend) {
                config.extend = ST.playable.Playable;
            };

            // inherit addEvent if needed, TODO fix this in ST.future.define()
            addEvent = config.addEvent || config.extend.prototype.addEvent;

            cls = ST.define(config);

            if (!me.prototype.hasOwnProperty('playables')) {
                me.prototype.playables = {};
            }
            me.prototype.playables[playableName] = cls; // glom on the playable class

            // element(), focus(), type() all return a future
            me.prototype[name] = function () {
                if (ST.LOGME) console.log('playable '+name+' called, arguments=',arguments,', params='+config.params);

                var me = this;

                // except... for WebDriver we don't want to instantiate a class just yet...
                // here we should just add the event and it's arguments???

                // TODO re-using addAction for states destroys instanceData/timeout/args...
                // TODO when do args for a State function such as focused() take more than just one param?

                if (addEvent) {
                    me.params = config.params; // TODO remove
                    return addEvent.apply(me, arguments);
                } else {
                    var rec = me._buildRec(name, arguments, config.params);
                    me.play(rec);
                    return me;
                }
            };
        },

        addPlayables: function (playables) {
            for (var name in playables) {
                this.addPlayable(name, playables[name]);
            }
        },

        createGetter: function (key) {
            return 'get' + (key.charAt(0).toUpperCase() + key.slice(1));
        },

        isFutureType: function (cls, type, deep) {
            cls = typeof cls === 'string' ? ST.clsFromString(cls).prototype : cls;

            // if deep, see if this desired type exists in the futureTypeMap
            if (deep !== false) {
                return type in cls.$futureTypeMap;
            }
            // otherwise, search for strict futureType correlation on the class
            else {
                return cls.$futureType === type;
            }
        }
    },

    constructor: function (config) {
        var me = this,
            config = config || {};

        if (!config.context) {
            config.context = ST.defaultContext;
        }

        ST.apply(me,config);

        me.isFuture = true;
    },

    /**
     * Schedules arbitrary actions for later execution. Often these actions are added
     * to the queue following {@link #tap} or other interactions in order to test an
     * expectation.
     *
     * For example:
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          and(function (el) {
     *              // Runs after the click event. We receive the ST.Element
     *              // wrapper for the "some-div" element.
     *
     *              expect(el.hasCls('foo')).toBe(true);
     *          });
     *
     * The future's value is passed as the first argument. For an Element future the arg
     * will be an {@link ST.Element}, for components it will be various things, typically
     * the component instance itself.
     *
     * The function's scope is set to the playable which includes a reference to the future
     * so the code above could be re-written as:
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          and(function () {
     *              expect(this.future.el.hasCls('foo')).toBe(true);
     *          });
     *
     * Functions that need to perform asynchronous actions can declare a 2nd argument
     * (typically called "done").
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          and(
     *              function (el, done) {
     *                  expect(el.hasCls('foo')).toBe(true);
     *
     *                  Ext.Ajax.request({
     *                      ...
     *                      callback: function () {
     *                          done();
     *                      }
     *                  });
     *              }
     *          );
     *
     * Multiple actions can be listed in a single call. Asynchronous actions can override
     * the {@link ST.options#timeout timeout} by specifying a number as the
     * previous argument.
     *
     * For example:
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          and(
     *              1000,   // timeout for following async steps in this and()
     *
     *              function (el, done) {
     *                  expect(el.hasCls('foo')).toBe(true);
     *
     *                  Ext.Ajax.request({
     *                      ...
     *                      callback: function () {
     *                          done();
     *                      }
     *                  });
     *              },
     *              function (el) {
     *                  expect(el.hasCls('foo')).toBe(false);
     *              }
     *          );
     *
     * @param {Number/Function...} fnOrTimeout One or more functions to invoke or timeout
     * values. For functions, the 1st argument will be the future value such as ST.Element
     * or an Ext.Component. The scope of functions will be the playable itself. To access
     * the future use this.future. Functions that declare a 2nd argument must call the
     * provided function to indicate that they are complete. Timeout values affect subsequent
     * asynchronous functions and override the {@link ST.options#timeout timeout}. These
     * timeouts only apply to functions passed in the current call.
     *
     * @return {ST.future.Element} this
     * @chainable
     */
    and: function () {
        var me = this,
            events = [],
            timeout; // undefined so we get "player.timeout || ST.options.timeout"

        ST.each(arguments, function (fn) {
            var wrapFn;

            if (typeof fn === 'number') {
                timeout = fn;
            }
            else {
                if (fn.length > 1) {
                    wrapFn = function (done) {
                        return fn.call(this, me._value(), done);
                    };
                } else {
                    wrapFn = function () {
                        return fn.call(this, me._value());
                    };
                }

                events.push(me._buildRec('and', {
                    remoteable: false,
                    fn: wrapFn,
                    timeout: timeout
                }));
            }
        });

        me.play(events);
        return me;
    },

    /**
     * @method wait
     * @chainable
     * Schedules a wait a specified amount of time (in milliseconds) or until a provided
     * function returns a truthy value.
     *
     * For example:
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *
     *          wait(100).  // wait 100ms
     *
     *          and(function (el) {
     *              // Runs after the click event. We receive the ST.Element
     *              // wrapper for the "some-div" element.
     *
     *              expect(el.hasCls('foo')).toBe(true);
     *          });
     *
     * Sometimes the condition on which a wait is based cannot be handles via callbacks
     * or events and must be polled. That is, one must check and re-check at some short
     * interval to determine if the condition is satisfied.
     *
     * For example:
     *
     *      var t = 0;
     *
     *      setTimeout(function () {
     *          t = 1;
     *      }, 1000);
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *
     *          wait(function (el) {
     *              // this test method ignores the el (ST.Element) argument
     *              // for demonstration purposes.
     *              return t;
     *          }).
     *
     *          and(function (el) {
     *              // Runs after the click event and when t is truthy. We receive the
     *              // ST.Element wrapper for the "some-div" element.
     *
     *              expect(el.hasCls('foo')).toBe(true);
     *          });
     *
     * These can be combined as needed.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *
     *          wait(200, // wait 200ms
     *
     *              function (el) {
     *                  return t;  // poll this one until it is truthy
     *              },
     *
     *              300,  // wait 300ms
     *
     *              'Something interest', // message for the next fn's timeout reason
     *
     *              function (el) {
     *                  return el.somethingInteresting();
     *              }
     *          ).
     *
     *          and(function (el) {
     *              expect(el.hasCls('foo')).toBe(true);
     *          });
     *
     * @param {Number/String/Function...} delayOrPollFn One or more millisecond delays,
     * functions to poll for truthy return value or timeout messages for said functions.
     * @return {ST.future.Element} this
     */
    wait: function () {
        // TODO using wait with webdriver doesn't make much sense...
        // TODO maybe remove this function when webdriver context!!!

        var me = this,
            events = [],
            message;

        ST.each(arguments, function (delay) {
            var t = typeof delay,
                m = message;

            if (t === 'number') {
                events.push(me._buildRec('wait',{
                    remoteable: false,
                    delay: delay
                }));
            } else if (t === 'string') {
                message = delay;
            } else if (t === 'function') {
                // TODO this won't work for webdriver currently! :(
                events.push(me._buildRec('wait',{
                    waitingFor: message,
                    waitingState: 'truthy',
                    remoteable: false,
                    ready: function () {
                        // TODO replace me with this(playable).future._value() ???
                        // NOTE this will be executed in the local context (remote if webdriver)
                        if (delay.call(me, me._value(), me, this)) {
                            return this.setWaiting(false); // not "me"
                        }
                        return this.setWaiting(m || delay.toString(),
                            m ? 'ready' : 'truthy');
                    }
                }));

                message = null;
            } else {
                throw new Error('wait() accepts millisecond delays or functions');
            }
        });

        me.play(events);
        return this;
    },

    // funny business here... click() is what we want... but the type must be 'tap' for the context/injector to work
    // properly since it relies on the type of the event to match the browser-event-name...
    click: function () {
        return this.tap.apply(this,arguments);
    },

    /**
     * @method down
     * Returns a descendant `{@link ST.future.Element future element}` that corresponds
     * to the specified selector.
     *
     *      ST.element('@someElement').
     *          down('span').
     *          and(function (element) {
     *              // span is now available
     *          });
     *
     * If the specified selector for the descendant element cannot be resolved, the request will timeout.
     * @param {String} selector The DOM Query selector to use to search for the descendant
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element}
     * @chainable
     */
    down: function (selector, timeout) {
        return this._createRelatedFuture('ST.future.Element', 'down', selector, timeout);
    },

    /**
     * @method up
     * Returns an ancestor `{@link ST.future.Element future element}` that corresponds
     * to the specified selector.
     *
     *      ST.element('@someElement').
     *          up('div').
     *          and(function (element) {
     *              // div is now available
     *          });
     *
     * If the specified selector for the ancestor element cannot be resolved, the request will timeout.
     * @param {String} selector The DOM Query selector to use to search for the ancestor
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element}
     * @chainable
     */
    up: function (selector, timeout) {
        return this._createRelatedFuture('ST.future.Element', 'up', selector, timeout);
    },

    /**
     * @method child
     * Returns a direct child `{@link ST.future.Element future element}` that corresponds
     * to the specified selector.
     *
     *      ST.element('@someElement').
     *          child('p').
     *          and(function (element) {
     *              // p is now available
     *          });
     *
     * If the specified selector for the child element cannot be resolved, the request will timeout.
     * @param {String} selector The DOM Query selector to use to search for the child component
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element}
     * @chainable
     */
    child: function (selector, timeout) {
        return this._createRelatedFuture('ST.future.Element', 'child', selector, timeout);
    },

    isFutureType: function (type, deep) {
        return ST.future.Element.isFutureType(this, type, deep);
    },

    _splits: {},
    // args, params and config are all optional...
    // _buildRec(type,args,params,rec)
    // _buildRec(type,args,params)
    // _buildRec(type,rec)
    _buildRec: function (type, args, params, rec) {
        if (!params && !rec) {
            rec = args;
            params = null;
            args = null;
        }

        var me = this,
            rec = rec || {},
            parsedArgs = {};

        rec.type = type;

        if (args && params) {
            parsedArgs = me._decodeArgs(args,params,parsedArgs);
        }
        // always put args even if empty... so this.args.x is easier in fn's.
        rec.args = rec.args || {};

        // move the timeout parameter to the record if there was one
        if (typeof parsedArgs.timeout !== 'undefined') {
            rec.timeout = parsedArgs.timeout;
            delete parsedArgs.timeout;
        }

        ST.apply(rec.args, parsedArgs);

        // TODO this is also done in me.play() so probably a dupe :(
        rec.future = rec.future || me;
        rec.futureClsName = rec.future.$className;

        return rec;
    },

    _decodeArgs: function (args,params,rec) {
        var me = this,
            params = params || 'timeout',
            splits = me._splits,
            array = splits[params],
            n = args.length,
            a = args[0],
            i, value;

        if (n === 1 && a && a.constructor === Object) {
            ST.apply(rec, a);
        } else {
            if (!array && params) {
                splits[params] = array = params.split(',');
            }

            n = Math.min(n, array.length);

            for (i = 0; i < n; ++i) {
                value = ST.encodeRegex(args[i]);
                rec[array[i]] = value;
            }
        }

        return rec;
    },

    //-----------------------------------------------------------------
    // Private

    _createRelatedFuture: function (maker, direction, locator, timeout) {
        var me = this,
            // locatorChain is setup automatically during construction,
            // so we'll just make a copy and add to it for the related playable/future
            locatorChain = ST.Array.slice(me.locatorChain || []),
            future, cls;

        cls = ST.clsFromString(maker);        
        future = new cls();

        return future.findInHierarchy({
            target: locator,
            // Pass the locator chain as the root; ST.Locator can use this to walk the heirarchy and build out the correct
            // element chain before looking up the current element
            root: locatorChain,
            direction: direction,
            timeout: timeout,
            locatorChain: locatorChain
        }, timeout);
    },

    _getContext: function () {
        var locator = this.locator,
            context = locator && locator.context || null;

        return context;
    },

    /**
     * @private
     * Called internally by and()
     * Will return the `valueProperty` of the currently "active" future
     * For in-browser tests, this could be an Ext JS Component, an ST.Element, or a full future
     * For WebDriver-based tests, this will always be the future
     */
    _value: function () {
        var me = this,
            valueProperty = me.valueProperty,
            value = me;

        // el/cmp are on the future, so just return them if we have a value property
        if (valueProperty && me[valueProperty]) {
            value = me[valueProperty];
        }

        return value;
    },

    _getFocusEl: function () {
        return this.el;
    },

    // helper function to attach things to each event
    play: function (events) {
        var me = this,
            context = me.context;

        if (!ST.isArray(events)) {
            events = [events];
        }

        for (var i = 0; i < events.length; i++) {
            events[i].future = events[i].future || me; // a bit of a duplciation of effort ya? TODO
            events[i].futureClsName = events[i].future.$className;
        }

        return context.play(events)[0];
    },

    /**
     * @private
     * Convenience method for setting key/value pairs on the future's data object
     * @param {String/Object} name The name of the key to set, or an object of key-value pairs to set
     * @param {Object} value The value to set on the data object
     */
    setData: function (name,value) {
        var me = this;

        me.data = me.data || {};

        if (typeof name === 'object') {
            ST.apply(me.data, name);
        } else {
            me.data[name] = value;
        }
    },

    /**
     * @private
     * Convenience method for retrieving data from the future.
     * @param {String} [name] Provide the name of a key to scope the results, otherwise the full data object will be returned
     * @return {Object}
     */
    getData: function (name) {
        var me = this;

        me.data = me.data || {};

        if (me.data && name) {
            return me.data[name];
        } else {
            return me.data;
        }
    },

    /**
     * @private
     * Convenience method for creating a lasting relationship between two futures
     * @param {String} [name] The name of the key for the value, or an object of related futures
     * @param {ST.future.Component/ST.future.Element} future The future to which the relationship should be made
     */
    setRelated: function (name, future) {
        var me = this;

        me.related = me.related || {};

        if (typeof name === 'object') {
            ST.apply(me.related, name);
        } else {
            me.related[name] = future;
        }
    },

    /**
     * @private
     * Convenience method for retrieving related futures from the future.
     * @param {String} [name] Provide the name of a future to scope the results, otherwise the full "related" map will be returned
     * @return {Object}
     */
    getRelated: function (name) {
        var me = this;

        me.related = me.related || {};

        if (name) {
            return me.related[name];
        } else {
            return me.related;
        }
    },

    // for contentX actions
    emptyRe: /^\s*$/
});

ST.future.Element.addPlayables({
    /**
     * @method tap
     * @chainable
     * Schedules a click action at the specified relative coordinates.
     *
     *      ST.element('@some-div').
     *          click(10, 10);
     *
     * Or for a Component:
     *
     *      ST.component('#some-cmp').
     *          click(10, 10);
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object for a `type="click"` event. In this case, all other arguments are
     * ignored.
     *
     * This future will wait for the element to be visible before performing the click
     * action.
     *
     * @param {Number/Object} x The number of pixels from the left edge of the element.
     * @param {Number} y The number of pixels from the top edge of the element.
     * @param {Number} [button=0] The mouse button code for the click.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    tap: {
        // TODO change this back to "click" and get it to work with the injector/player

        params: 'x,y,button,timeout',
        target: function () {
            return this.future.locator;
        }
    },

    /**
     * @method content
     * @chainable
     * Waits for this element's `innerHTML` to match the specified value.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          content('Hello <b>world</b>');
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object (with an additional required `html` property). In this case, all
     * other arguments are ignored.
     * @param {String/Object} html The html to match.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     * @since 1.0.1
     */
    content: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('content', arguments, 'html,timeout', {
                    waitingFor: 'content',
                    waitingState: 'matching '
                });

            rec.waitingState += rec.args.html;

            me.play(rec);

            return me;
        },
        ready: function () {
            var me = this,
                html = me.args.html;

            if (ST.LOGME) console.log('content ready()? expected=' + html + ', actual=' + me.getDom().innerHTML);

            if (html === me.getDom().innerHTML) {
                return me.setWaiting(false);
            }
            return false;
        }
    },

    /**
     * @method contentEmpty
     * @chainable
     * Waits for this element's `innerHTML` to be empty.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          contentEmpty();
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object. In this case, all other arguments are ignored.
     * @param {Number/Object} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    contentEmpty: {
        params: 'timeout',
        waitingFor: 'content',
        waitingState: 'empty',
        ready: function () {
            if (ST.future.Element.prototype.emptyRe.test(this.getDom().innerHTML)) {
                return this.setWaiting(false);
            }
            return false;
        }
    },

    /**
     * @method contentLink
     * @chainable
     * Waits for this element's `innerHTML` to match the specified RegExp `pattern`.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          contentLike(/hello/i);
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object (with an additional required `pattern` property). In this case, all
     * other arguments are ignored.
     * @param {RegExp/String/Object} pattern The pattern to match. If this is a String, it
     * is first promoted to a `RegExp` by called `new RegExp(pattern)`.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    contentLike: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('contentLike', arguments, 'pattern,timeout', {
                    waitingFor: 'content',
                    waitingState: 'like '
                });

            rec.waitingState += rec.args.pattern;

            me.play([rec]);

            return me;
        },
        ready: function () {
            var pattern = ST.decodeRegex(this.args.pattern),
                re = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;

            if (re.test(this.getDom().innerHTML)) {
                return this.setWaiting(false);
            }
            return false;
        }
    },

    /**
     * @method contentNotEmpty
     * @chainable
     * Waits for this element's `innerHTML` to be non-empty.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          contentNotEmpty();
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object. In this case, all other arguments are ignored.
     * @param {Number/Object} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    contentNotEmpty: {
        params: 'timeout',
        waitingFor: 'content',
        waitingState: 'not empty',
        ready: function () {
            if (ST.LOGME) console.log('contentNotEmpty, actual=' + this.getDom().innerHTML);

            if (ST.future.Element.prototype.emptyRe.test(this.getDom().innerHTML)) {
                return false;
            }
            return this.setWaiting(false);
        }
    },

    /**
     * @method contentNotLike
     * @chainable
     * Waits for this element's `innerHTML` to not match the specified RegExp `pattern`.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          contentNotLike(/world/i);
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object (with an additional required `pattern` property). In this case, all
     * other arguments are ignored.
     * @param {RegExp/String/Object} pattern The pattern to match. If this is a String, it
     * is first promoted to a `RegExp` by called `new RegExp(pattern)`.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    contentNotLike: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('contentNotLike', arguments, 'pattern,timeout', {
                    waitingFor: 'content',
                    waitingState: 'not like '
                });

            rec.waitingState += rec.args.pattern;

            me.play([rec]);

            return me;
        },
        ready: function () {
            var pattern = ST.decodeRegex(this.args.pattern),
                re = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;

            if (!re.test(this.getDom().innerHTML)) {
                return this.setWaiting(false);
            }
            return false;
        }
    },

    // TODO docs
    documentReady: {
        params: 'state,timeout',
        is: function () {
            var state = this.args.state || 'complete';

            return document.readyState === state;
        },
        wait: function (done) {
            var state = this.args.state || 'complete',
                listener = function () {
                    if (document.readyState === state) {
                        done();
                    }
                };
            document.addEventListener('readystatechange', listener);

            return function () {
                document.removeEventListener('readystatechange', listener);
            }
        }
    },

    element: {
        addEvent: function (locator, timeout) {
            var me = this,
                locatorChain = [],
                comp = locator,
                available, root, direction;

            if (locator) {
                if (locator.constructor === Object) {
                    timeout = locator.timeout;

                    available = locator.available;
                    root = locator.root;
                    direction = locator.direction;
                    // if locatorChain is already defined, we'll add to it
                    locatorChain = locator.locatorChain || locatorChain;
                }

                // if the locator is an object, we don't want to add it to the chain as-is, since it's
                // probably a copy from a related future (like asComponent, et.al)
                // the locator chain will *already* have to correct path to the related future, so
                // we don't lose anything by skipping here!
                // for now, we'll add a fake locator so it doesn't get lost
                if (typeof locator !== 'object') {
                    // finish locatorChain
                    locatorChain.push({
                        direction: direction,
                        locator: locator,
                        futureClsName: me.$className,
                        type: me.$futureType
                    });
                }
                
                if (locator.isComponent || locator.isWidget) {
                    locator = locator.el || locator.element; // el=Ext, element=Touch
                }
            }

            me.timeout = timeout;

            if (locator) {
                if (locator.dom && !locator.$ST) {
                    locator = new ST.Element(locator.dom);
                }

                if (locator.dom) {
                    locatorChain.push({
                        el: locator,
                        futureClsName: me.$className,
                        type: me.$futureType
                    });
                }

                if (locatorChain) {
                    me.locatorChain = ST.Array.slice(locatorChain);
                }

                me.locator = me.play(me._buildRec(me.$futureType || 'element', {
                    target: locator, // TODO non-string target/locators!
                    visible: null,  // don't worry about visibility...
                    animation: false, // ...or animations at this stage
                    available: available,
                    root: root,
                    direction: direction,
                    timeout: timeout,
                    locatorChain: locatorChain
                }));
            }

            if (comp && !me.locator) {
                // If me.locator is not setup that means the component is not rendered.
                // With Sencha Touch and Ext JS 6 (Modern) this is never the case.
                if (comp.constructor === Object) {
                    comp = comp.locator;
                }

                if (comp.isComponent) {
                    me.cmp = comp;

                    me.locator = function () {
                        return comp.el;  // no need to worry about Modern/Touch
                    };
                }
            }

            return me;
        },
        fn: function () {
            var me = this,
                future = me.future,
                context = me.context;

            if (ST.LOGME) console.log('future.el = this.targetEl = ', this.targetEl);

            future.el = this.targetEl;
            // TODO for webdriver attaching here is kind of a waste-ish???
            if (future._attach) {
                future._attach();
                if (ST.LOGME) console.log('after _attach(), future.cmp=', future.cmp);
            }
        }
    },

    /**
     * @method expect
     * @chainable
     * Schedules an expectation on a getter or property of the given component or element future. The expect() call
     * returns a set of matchers. The matcher funtions return the current future for further chaining.
     *
     *      ST.textField('@username')
     *          .type('test-username')
     *          .expect('text').toBe('test-username')
     *          .textField('@password')
     *          .type('test-password')
     *          .expect('text').toBe('text-password');
     *
     * Similar to {@link ST.future.Component.get} the string property name is used for getter or property access. Requesting
     * 'foo' would cause the following to be attempted. The first strategy to work will cause that value to be used for
     * the actual value in the comparison.
     *
     *      - Ext.Component.getFoo()
     *      - Ext.Component.foo
     *      - ST.Element.getFoo()
     *      - ST.Element.foo
     *      - ST.Element.dom.foo
     *
     *      ST.component('@my-container')
     *      // component getter
     *      .expect('XTypes').toBe('component/box/container/my-container')
     *      // component property
     *      .expect('height').toBe(100)
     *      // ST.Element getter
     *      .expect('text').toBe('Hello')
     *      // ST.Element property
     *      .expect('isElement').toBe(true)
     *      // dom property
     *      .expect('innerText').toBe('Hello');
     *
     * Custom jasmine matchers are included. "not" is supported. Other matchers such as jasmine.any(<type>),
     * jasmine.objectContaining and jasmine.anything() are supported as well.
     *
     *      ST.textField('@futureCmp')
     *      .expect('aString').toBe('bar')
     *      .expect('aString').not.toBe('baz')
     *      .expect('aString').toEqual(jasmine.any(String))
     *      .expect('aString').not.toEqual(jasmine.any(Number))
     *      .expect('aNumber').toBe(42)
     *      .expect('aNumber').not.toBe(23)
     *      .expect('aNumber').toEqual(jasmine.any(Number))
     *      .expect('aNumber').not.toEqual(jasmine.any(String))
     *      .expect('anObject').toEqual(jasmine.anything())
     *      .expect('anObject').toEqual(jasmine.objectContaining({a:1,b:2}))
     *      .expect('anObject').not.toEqual(jasmine.objectContaining({c:3}))
     *      .expect('notThere').not.toEqual(jasmine.anything())
     *
     * @param {String} property name to compare against
     * @return stub resembling jasmine Expectation class
     */
    expect: {
        remotable: false,
        ready: function () {
            return true;
        },
        addEvent: function () {
            var ex = new ST.Expect(this,arguments);
            return ex;
        }
    },
    
    execute: {
        // TODO make this take flexible args...
        // first arg is a function then the fn is called like fn.call(playable,playable.future._value())
        // similar to and() used to work

        // if first arg is NOT a function... then just pass args on...
        params: 'fn',
        remoteable: false,
        ready: function () {
            return true;
        },
        fn: function (done) {
            var me = this;
            me.context.execute(me, me.args.fn, function (ret) {
                me.future.setData('executeResult',ret);
                me.future.setData('executeError',null);
                done();
            }, function (err) {
                me.future.setData('executeResult',null);
                me.future.setData('executeError',err);
                done();
            });
        }
    },

    /**
     * @private
     * Schedules an event to locate a hierarchical component/element
     */
    findInHierarchy: {
        addEvent: function (config, timeout) {
            var me = this,
                rec = me._buildRec('element', {
                    timeout: timeout,
                    target: config.locator
                });

            config.locatorChain.push({
                direction: config.direction,
                locator: config.target,
                futureClsName: me.$className,
                type: (!me.$futureType || me.$futureType === 'element') ? 'element' : 'component'
            });

            me.root = config.locatorChain;
            me.locatorChain = config.locatorChain;
            me.locator = me.play(ST.apply(rec, config));

            return me;
        }
    },

    /**
     * @method focus
     * @chainable
     * Schedules the component to receive the focus.
     *
     *      ST.element('@some-div/input').
     *          focus();
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object. In this case, all other arguments are ignored.
     * @param {Number/Object} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    focus: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('focus', arguments, 'timeout');
            me.play(rec);
            return me.focused(100);
        },
        fn: function () {
            var el = this.future._getFocusEl();
            if (el) {
                el.focus();
            }
        }
    },

    /**
     * @method get
     * Retrieves the values of the specified list of properties from the future's 
     * underlying ST.Element. These values will then be available on the future itself 
     * (for example, to be used in expectations within an and() method).
     *
     * This method is particularly useful for WebDriver-based tests where direct access to DOM elements 
     * is not possible within the context of the executed spec. 
     *
     *      ST.element('#mydiv')
     *          .get('className')
     *          .and(function () {
     *              expect(this.future.data.className).toContain('foo');
     *          })
     *
     * @param {String[]} properties A comma-delimited list of property values to retrieive from the ST.Element
     * @return {ST.future.Element} this
     * @chainable
     */
    get: {
        params: 'names,timeout',
        fn: function () {
            var me = this,
                future = me.future,
                names = me.args.names.split(','),
                el = me.getElement(),
                len = names.length,
                i, key, val, getter;

            future.data = future.data || {}; // TODO change "data" to "get_data" or something?

            if (el) {
                for (i = 0; i < len; i++) {
                    key = names[i];
                    getter = el[ST.future.Element.createGetter(key)];

                    if (getter) {
                        future.data[key] = getter.call(el);
                    } else {
                        // check ST element first
                        val = el[key];
                        // if property isn't found on ST element, check dom if we have it
                        if (val === undefined && el.dom) {
                            val = el.dom[key];
                        }

                        if (val !== undefined) {
                            future.data[key] = val;
                        }
                    }
                }
            }
        }
    },

    // getAttribute
    // getCssProperty
    // getElementSize
    // getHTML
    // getLocation - location of dom in page
    // getLocationInView
    // getSource
    // getTagName
    // getText
    // getTitle
    // getUrl
    // getValue

    // TODO automate the adding of webdriver pass-throughs on both the Element and the impl on WebDriver context.
    getTitle: {
        params: 'callback,timeout',
        remoteable: false,
        fn: function (done) {
            var me = this;

            this.context.getTitle(function(title) {
                me.args.callback(title);
                done();
            });
        }
    },

    /**
     * Retrives the current url of the target browser
     *
     *   ST.getUrl(function (url) {
     *      console.log(url);
     *   });
     *
     * @param {Function} callback The callback function to execute when the url has been determined
     * @return {ST.future.Element}
     * @method getUrl
     * @chainable
     */
    getUrl: {
        params: 'callback,timeout',
        remoteable: false,
        fn: function (done) {
            var me = this;

            this.context.getUrl(function(url) {
                me.args.callback(url);
                done();
            });
        }
    },

    /**
     * @method navigate
     * @chainable
     * Instructs the browser to load the specified URL string
     *
     *      ST.element('@some-div').
     *          navigate('https://www.google.com')
     *          input('@another-div').
     *          navigate('https://www.sencha.com')
     *          input('@a-third-div');
     *
     * NOTE: Using this method to navigate away from the page in a non-WebDriver test
     * will halt the test execution. It is possible to use this to navigate to different anchors
     * on the same page:
     *
     *      ST.getUrl(function (url) {
     *          ST.navigate(url+'#first-anchor').
     *              element('@some-div');
     *   });
     *
     * If URL begins with '#' then the page will be redirected to that anchor.
     *
     * @param {String} url The URL to navigate to.
     * @return {ST.future.Element}
     */
    navigate: {
        remoteable: false,
        params: 'url',
        fn: function () {
            this.context.url(this.args.url);
        }
    },
    
    /**
     * @method screenshot
     * @chainable
     * Takes a snapshot of the viewport and compares it to the associated baseline image.
     *
     *      ST.element('@someEl').
     *          click(10, 10).
     *          screenshot();
     *
     * @param {String} name
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    screenshot:  {
        params: 'name,tolerance',
        remoteable: false,
        timeout: 30 * 1000,
        fn: function (done) {
            var me = this,
                args = me.args,
                name = args.name,
                tolerance = args.tolerance;

            me.context.screenshot(name, tolerance, function (err, comparison) {
                me.future.setData('error', err);
                me.future.setData('comparison', comparison);
                done();
            });
        }
    },

    /**
     * @method text
     * @chainable
     * Waits for this element's `textContent` to match the specified string.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          text('Hello world');
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object (with an additional required `text` property). In this case, all
     * other arguments are ignored.
     * @param {String/Object} text The text to match.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     * @since 1.0.1
     */
    text: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('text', arguments, 'text,timeout', {
                    waitingFor: 'text',
                    waitingState: 'matching '
                });

            rec.waitingState += rec.args.text;

            me.play([rec]);

            return me;
        },
        ready: function () {
            var text = this.args.text;

            var t = this.getElement().getText();

            if (text === t) {
                return this.setWaiting(false);
            }

            return false;
        }
    },

    /**
     * @method textEmpty
     * @chainable
     * Waits for this element's `textContent` to be empty.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          textEmpty();
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object. In this case, all other arguments are ignored.
     * @param {Number/Object} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    textEmpty: {
        params: 'timeout',
        waitingFor: 'text',
        waitingState: 'empty',
        ready: function () {
            var text = this.getElement().getText();

            if (ST.future.Element.prototype.emptyRe.test(text)) {
                return this.setWaiting(false);
            }

            return false;
        }
    },

    /**
     * @method textLike
     * @chainable
     * Waits for this element's `textContent` to match the specified RegExp `pattern`.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          textLike(/hello/i);
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object (with an additional required `pattern` property). In this case, all
     * other arguments are ignored.
     * @param {RegExp/String/Object} pattern The pattern to match. If this is a String, it
     * is first promoted to a `RegExp` by called `new RegExp(pattern)`.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    textLike: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('textLike', arguments, 'pattern,timeout', {
                    waitingFor: 'text',
                    waitingState: 'like '
                });

            rec.waitingState += rec.args.pattern;

            me.play([rec]);

            return me;
        },
        ready: function () {
            var text = this.getElement().getText(),
                pattern = ST.decodeRegex(this.args.pattern),
                re = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;

            if (re.test(text)) {
                return this.setWaiting(false);
            }

            return false;
        }
    },

    /**
     * @method textNotEmpty
     * @chainable
     * Waits for this element's `textContent` to be non-empty.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          textNotEmpty(200);
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object. In this case, all other arguments are ignored.
     * @param {Number/Object} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    textNotEmpty: {
        params: 'timeout',
        waitingFor: 'text',
        waitingState: 'not empty',
        ready: function () {
            var text = this.getElement().getText();

            if (ST.future.Element.prototype.emptyRe.test(text)) {
                return false;
            }

            return this.setWaiting(false);
        }
    },

    /**
     * @method textNotLike
     * @chainable
     * Waits for this element's `textContent` to not match the specified RegExp `pattern`.
     *
     *      ST.element('@some-div').
     *          click(10, 10).
     *          textNotLike(/hello/i, 200);
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object (with an additional required `pattern` property). In this case, all
     * other arguments are ignored.
     * @param {RegExp/String/Object} pattern The pattern to match. If this is a String, it
     * is first promoted to a `RegExp` by called `new RegExp(pattern)`.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    textNotLike: {
        addEvent: function () {
            var me = this,
                rec = me._buildRec('textNotLike', arguments, 'pattern,timeout', {
                    waitingFor: 'text',
                    waitingState: 'not like '
                });

            rec.waitingState += rec.args.pattern;
            me.play([rec]);

            return me;
        },
        ready: function () {
            var text = this.getElement().getText(),
                pattern = ST.decodeRegex(this.args.pattern),
                re = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;

            if (!re.test(text)) {
                return this.setWaiting(false);
            }

            return false;
        }
    },

    /**
     * @method timedout
     * @chainable
     * Expects the last futures method to timeout and adds a test result explaining
     * the desired state. Such as:
     *
     *      expected timeout waiting for '[input]' to be ready for element
     *
     * @return {ST.future.Element} this
     */
    timedout: {
        remoteable: false,
        addEvent: function () {
            var player = ST.player();
            player.events[player.events.length-1].expectTimeout = true;
            return this;
        }
    },
    
    /**
     * @method type
     * @chainable
     * Schedules a "type" action at the specified relative coordinates.  This method
     * assumes you have already achieved correct focus of the target and that the
     * target is visible. If the target is not visible this future will timeout.
     *
     *      ST.element('@some-div/input').
     *          focus().
     *          type('Hello world');
     *
     * If first argument is an object, it should be a {@link ST.playable.Playable playable}
     * config object for a `type="type"` event. In this case, all other arguments are
     * ignored.
     *
     * @param {String/Object} text The text to type.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait for the
     * typing to finish.
     * @return {ST.future.Element} this
     */
    type: {
        params: 'text,timeout',
        target: function () {
            var me = this,
                el = me.future._getFocusEl();
            return el && el.dom;
        }
    },

    /*
     * waitFor(<object>)
     *
     * wait for the future.getValue() to match any provided properties in the given object.
     */
    // waitFor: {
    //     // TODO
    // }

    /**
     * @method hasCls
     * @chainable
     * Waits for this element to have a specified CSS class.
     *
     *      ST.element('@someEl').
     *          hasCls('foo').
     *          and(function (el) {
     *              // el is now does has a "foo" class
     *          });
     *
     * @param {String} cls The class name to test.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    hasCls: {
        // TODO move back to a function???
        params: 'cls,timeout',
        is: function () {
            return this.getElement().hasCls(this.args.cls); // TODO test
        }
    },

    /**
     * @method hidden
     * @chainable
     * Waits for this element to become hidden.
     *
     *      ST.element('@someEl').
     *          hidden().
     *          and(function (el) {
     *              // el is now hidden
     *          });
     *
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    hidden: {
        is: function () {
            return !this.getElement().isVisible();
        }
    },

    /**
     * @method missingCls
     * @chainable
     * Waits for this element to not have a specified CSS class.
     *
     *      ST.element('@someEl').
     *          missingCls('foo').
     *          and(function (el) {
     *              // el is now does not have a "foo" class
     *          });
     *
     * @param {String} cls The class name to test.
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    missingCls: {
        params: 'cls,timeout',
        is: function () {
            return !this.getElement().hasCls(this.args.cls);
        }
    },

    /**
     * @method navigated
     * @chainable
     * Waits for the given URL to be loaded.
     *
     * @param {String} url The url to check
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    navigated: {
        params: 'url,timeout',
        is: function (url) {
            // TODO broken? this.args.url instead of url???
            // TODO assert Ext stuff is ready... by calling this.context.extReady()... probably need a ready function instead with a done!!!
            return window.location === url;
        }
    },

    /**
     * @method removed
     * @chainable
     * Waits for this element to be removed from the document.
     *
     *      ST.element('@someEl').
     *          removed().
     *          and(function (el) {
     *              // el is now removed from the document
     *          });
     *
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    removed: {
        is: function () {
            return !ST.fly(document.body).contains(this.getElement());
        },
        available: false
    },

    /**
     * @method visible
     * @chainable
     * Waits for this element to become visible.
     *
     * Event injection methods automatically wait for target visibility, however, if
     * using `and` sequences explicitly waiting for visibility may be necessary.
     *
     *      ST.element('@someEl').
     *          visible().
     *          and(function (el) {
     *              // el is now visible
     *          });
     *
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    visible: {
        is: function () {
            return this.getElement().isVisible();
        }
    },

    /**
     * @method focused
     * @chainable
     * Waits for this element to become focused.
     *
     *      ST.element('@someEl').
     *          focused().
     *          and(function (el) {
     *              // el is now hidden
     *          });
     *
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    focused: {
        is: function () {
             return document.activeElement === this.future._getFocusEl().dom;
        }
    },

    /**
     * @method blurred
     * @chainable
     * Waits for this element to become blurred.
     *
     *      ST.element('@someEl').
     *          focused().
     *          and(function (el) {
     *              // el is now hidden
     *          });
     *
     * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
     * @return {ST.future.Element} this
     */
    blurred: {
        is: function () {
            return document.activeElement !== this.future._getFocusEl().dom;
        }
    }

    /*
     * snapshot: function () {}
     * */
});

/**
 * @method absent
 * @chainable
 * @member ST
 * Schedules a wait for an element to be absent or missing from the DOM. This is typically
 * used after some future action that should cause a removal.
 *
 *      ST.button('@okButton').click();
 *      ST.absent('@confirmationWindow'); // the window owning the OK button
 *
 * This method is similar to `{@link ST.future.Element#removed}` but the difference
 * is that this method does not first wait for the specified element to be found. This
 * difference makes this method suitable for checking for things that should not be
 * present in the first place.
 *
 * @param {String} locator See {@link ST.Locator} for supported syntax.
 * @param {Number} [timeout] The maximum time (in milliseconds) to wait for the element
 * to be removed.
 * @return {ST.future.Element}
 */
ST.absent = function (locator, timeout) {
    return new ST.future.Element({
        locator: locator,
        timeout: timeout,
        available: false
    });
};

/**
 * Returns a limited-use {@link ST.future.Element future} that can be used only to
 * {@link ST#wait wait} and perform some
 * {@link ST.future.Element#method-and manual steps}.
 * @return {ST.future.Element}
 * @method wait
 * @member ST
 */
ST.wait = function () {
    var future = new ST.future.Element();
    return future.wait.apply(future, arguments);
};

/**
 * Returns a {@link ST.future.Element future element} used to queue operations for
 * when that element becomes available (rendered to the page). The element does not
 * need to be visible for this future to complete.
 *
 * Once a future is returned from this method, it is typically used to describe some
 * sequence of actions, wait for state transitions and perform inspections.
 *
 *      ST.element('@someEl').
 *          click(10, 10).
 *          textLike(/hello/i).
 *          and(function (el) { ... });
 *
 * @param {String} locator See {@link ST.Locator} for supported syntax.
 * @param {Number} [timeout] The maximum time (in milliseconds) to wait for the element.
 * @return {ST.future.Element}
 * @method element
 * @chainable
 * @member ST
 */
ST.element = function (locator, timeout) {
    var future = new ST.future.Element();
    return future.element(locator, timeout);
};

// TODO need this?
ST.context.Base.prototype.element = function (locator, timeout) {
    var future = new ST.future.Element({
        context: this
    });
    return future.element(locator, timeout);
};

ST.execute = function (fn) {
    return new ST.future.Element().execute(fn);
};

/**
 * Instructs the browser to load the specified URL string.
 *
 *   ST.navigate('https://www.google.com')
 *     input('input[title="Search"]').
 *     type('hello');
 *
 *
 * NOTE: Using this method to navigate away from the page in a non-WebDriver test
 * will halt the test execution. It is possible to use this to navigate to different anchors
 * on the same page:
 *
 *   ST.getUrl(function (url) {
 *      ST.navigate(url+'#first-anchor')
 *         .element('@some-div');
 *   });
 *
 * If URL begins with '#' then the page will be redirected to that anchor.
 *
 * @param {String} url The URL to navigate to.
 * @return {ST.future.Element}
 * @method navigate
 * @chainable
 * @member ST
 */
ST.navigate = function (url) {
    var future = new ST.future.Element();
    return future.navigate(url);
};

/**
 * Waits for the browser to load the specified URL string.
 *
 *   ST.navigated('https://www.google.com');
 *
 * @param {String} url The URL to navigate to.
 * @param {Number} [timeout] The maximum time (in milliseconds) to wait.
 * @return {ST.future.Element}
 * @method navigated
 * @chainable
 * @member ST
 */
ST.navigated = function (url, timeout) {
    var future = new ST.future.Element();
    return future.navigated(url, timeout);
};

// TODO docs
ST.documentReady = function (state, timeout) {
    var future = new ST.future.Element();
    return future.documentReady(state, timeout);
};

// TODO docs
ST.screenshot = function (name, tolerance) {
    var future = new ST.future.Element();
    return future.screenshot(name, tolerance);
}

/**
 * Retrives the current url of the target browser
 *
 *   ST.getUrl(function (url) {
 *      console.log(url);
 *   });
 *
 * @param {Function} callback The callback function to execute when the url has been determined
 * @return {ST.future.Element}
 * @method getUrl
 * @chainable
 * @member ST
 */
ST.getUrl = function (callback) {
    ST.defaultContext.getUrl(callback);
};
// TODO attach this to the context also so it can be relative to multiple context instances...

ST.future.classes = [];

ST.future.define = function (componentName, body) {
    if (!body.extend) {
        body.extend = ST.future.Element;
    }

    var playables = body.playables;
    delete body.playables;

    var extend = body.extend,
        mixins = body.mixins,
        cls = ST.define(body), // deletes body.extend
        parts = componentName.split('.'),
        methodScope = ST,
        classScope = ST.future,
        futureType,
        name;


    while (parts.length > 1) {
        name = parts.shift();

        if (!classScope[name]) {
            classScope[name] = {};
        }
        if (!methodScope[name]) {
            methodScope[name] = {};
        }
    }

    name = parts[0];
    futureType = ST.decapitalize(name);

    // ensure that THIS prototype has a playables property
    cls.prototype.playables = {};

    cls.prototype.$playables = {}; // save the config for inheritance

    // track the classes being defined
    ST.future.classes.push(cls);

    // add mixin playables
    if (mixins) {
        mixins = ST.isArray(mixins) ? mixins : [mixins];

        for (i=0; i<mixins.length; i++) {
            mixin = mixins[i].prototype;

            if (mixin.$playables) {
                cls.addPlayables(mixin.$playables);
            }
        }
    }

    if (body.factoryable === false) {
        delete cls.prototype.factoryable;
    } else {
        ST.context.Base.prototype[futureType] = function (locator, timeout) {
            var future = new cls({
                context: this
            });
            return future[futureType](locator, timeout);
        };

        // ST.button() for example
        methodScope[futureType] = function (locator, timeout) {
            var future = new cls();
            return future[futureType](locator, timeout);
        };

        var superType = cls.superclass.$futureType || 'element',
            superPlayableCls = extend.prototype.playables[ST.capitalize(superType)];

        // Button
        // superType 'component'
        // ST.future.Component.prototype.playables.Component (really the config from 'element' playable)

        // Component
        // superType 'element'
        // ST.future.Element.prototype.playables.Element

        if (!cls.prototype[futureType]) {
            // no type specific method for adding event so use superclass method
            cls.addPlayable(futureType, {
                extend: superPlayableCls
            });
        }
    }

    if (extend.prototype.$playables) {
        cls.addPlayables(extend.prototype.$playables);
    }

    // after any superclass playables are added, add the ones for this class...
    // allows for overrides such as Component.get() over Element.get()

    if (playables) {
        cls.addPlayables(playables);
    }

    // record the full class name on the prototype so we can re-build it in webdriver remote browser
    cls.prototype.$className = 'ST.future.' + componentName;
    cls.prototype.$futureType = futureType;

    // track futureType inheritance
    var futureTypeChain = cls.prototype.$futureTypeChain;
    var futureTypeMap = cls.prototype.$futureTypeMap;

    if (!cls.prototype.hasOwnProperty('$futureTypeChain')) {
        cls.prototype.$futureTypeChain = futureTypeChain = futureTypeChain ? futureTypeChain.slice(0) : [];
        cls.prototype.$futureTypeMap = futureTypeMap = ST.apply({}, futureTypeMap);
    }

    futureTypeChain.push(futureType);
    futureTypeMap[futureType] = true;

    return classScope[ST.capitalize(name)] = cls;
};
