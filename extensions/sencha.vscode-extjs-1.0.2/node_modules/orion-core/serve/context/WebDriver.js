/**
 * @class ST.context.WebDriver
 * @private
 */
(function() {
    var DEBUG_ME = false,
        WebDriver;
    // TODO would be nice here if Context handled creation of playables...
    // then I could push in a default number of tries for callFn/ready/loadST..

    ST.context.WebDriver = ST.define({
        extend: ST.context.Base,

        // TODO Context interface
        /**
         * @cfg {Boolean} eventTranslation
         * `false` to disable event translation.  If `false` events that are not supported by
         * the browser's event APIs will simply be skipped.
         * NOTE: inherited from Player
         */
        eventTranslation: true,

        /**
         * @cfg {Boolean} visualFeedback
         * `false` to disable visual feedback during event playback (mouse cursor, and "gesture"
         * indicator)
         * NOTE: inherited from Player
         */
        visualFeedback: true,

        _STContent: "",

        isWebDriverContext: true,

        hbRE: /.*STHB:/,
        msgRE: /.*STM:/,

        constructor: function (config) {
            ST.context.WebDriver.superclass.constructor.call(me, config);
            // TODO making a new webdriverio.remote().init() when one already
            // exists doesn't really do anything... so maybe prohibit this???

            var me = this;

            ST.apply(me, config);

            me.targetMessages = [];
            me.targetLogs = [];

            // TODO put these in the magical Studio preferences file for manual tweaking in the field.
            me.logPollInterval = 500;
            me.heartbeatInterval = 250;
            me.heartbeatFailureThreashold = 3000;

            me._prefetchSTContent();
        },

        init: function () {
            var me = this;

            return new Promise(function (resolve, reject) {
                if (DEBUG_ME) debugger

                // TODO hide me.driver and ST.webdriverio so they can't be fooled with by users...
                // instead provide some similar methods like execute/executeAsync
                // TODO clean this up with some functions and .co yield() ???
                me.driver = ST.webdriverio
                    .remote(me.driverConfig)
                    .init(me.driverConfig)
                    .then(function (ret) {
                        // TODO ret returns a BUNCH Of useful information... capture!???!?
                        if (ST.LOGME) console.log('webdriver init ret='+JSON.stringify(ret));
                        if (ret.value && ret.value.browserName && ret.value.browserName === 'chrome') {
                            me.LOGS_SUPPORTED = true;
                            me.pollLogs();
                        } else {
                            me.LOGS_SUPPORTED = false;
                        }
                    }, function (err) {
                        var message;
                        if (err.seleniumStack) {
                            message = err.seleniumStack;
                        } else {
                            message = err.message || err;
                        }
                        reject(message);
                    })
                    .timeouts('script', 10 * 1000)
                    .then(function (ret) {
                        if (me.subjectUrl) {
                            me.driver.url(me.subjectUrl).then(function (ret) {
                                me._loadST().then(resolve, reject);
                            }, function (err) {
                                    reject('Error loading url: ' + me.subjectUrl + ', err: ' + err);
                                });
                        } else {
                            if (ST.LOGME) console.log('no subjectUrl in WebDriver constructor config options...');
                            resolve();
                        }
                    })
                    .catch(function (err) {
                        if (ST.LOGME) console.log('webdriver init err=',err);
                        reject(err);
                    });

                ST.client = me.driver; // TODO helper to let people use the webdriver API if they wish.
            });
        },

        initEvent: function (event) {
            if (!ST.playable.Playable.isRemoteable(event)) {
                return this.createPlayable(event);
            } else {
                // for WebDriver we want the player to keep the "bare" Playable config
                // since we create the playable in the target only.
                return event;
            }
        },

        // TODO include project/scenario libraries?!?!
        _prefetchSTContent: function () {
            var fs = require('fs'),
                path = require('path'),
                serveDir = ST.serveDir,
                files = [
                    'init.js',
                    'supports.js',
                    'base.js',
                    'Version.js',
                    'common.js',
                    'Timer.js',
                    'setup-ext.js',
                    'context/Base.js',
                    'context/Local.js',
                    'context/LocalWebDriver.js',
                    'Browser.js',
                    'OS.js',
                    'Element.js',
                    'KeyMap.js',
                    'Alert.js',
                    'event/Event.js',
                    'event/wgxpath.install.js',
                    'Locator.js',
                    'locator/Strategy.js',
                    'event/Driver.js',
                    'event/Recorder.js',
                    'playable/Playable.js',
                    'playable/State.js',
                    'future/Element.js',
                    'future/Component.js',
                    'tail.js'
                ],
                content = {};

            for (var i=0; i<files.length; i++) {
                content[files[i]] = fs.readFileSync(path.join(serveDir, files[i]), {encoding:'utf8'});
            }

            this._STContent = content;
        },

        displayModal: function (text) {
            var me = this,
                driver = me.driver;

            // This modal is mainly used for the Event Recorder, so set the default text to that.
            text = text || 'Sencha Test Event Recorder is loading, this message will be dismissed when ready to record.';

            return new Promise(function (resolve, reject) {
                if (me.isRecording) {
                    /**
                     * @method execute
                     * display a modal dialog in the target that overlays and masks all other elements on
                     * the page. This alert does not block the application like the standard DOM `alert()`
                     * method.
                     */
                    driver.execute(function (_text) {
                        // IN-BROWSER-BEGIN
                        var modal = document.createElement('div'),
                            modalDialog = document.createElement('div'),
                            modalText = document.createElement('span'),
                            modalIndicator = document.createElement('div');

                        modal.id = 'StudioModal';
                        modal.style.display = 'block';
                        modal.style.position = 'fixed';
                        modal.style.zIndex = '99999';
                        modal.style.top = '0';
                        modal.style.left = '0';
                        modal.style.width = '100%';
                        modal.style.height = '100%';
                        modal.style.paddingTop = '100px';
                        modal.style.backgroundColor = 'rgb(0,0,0)';
                        modal.style.backgroundColor = 'rgba(0,0,0,0.4';

                        modalDialog.style.margin = 'auto';
                        modalDialog.style.position = 'absolute';
                        modalDialog.style.top = '10%';
                        modalDialog.style.left = '10%';
                        modalDialog.style.width = '80%';
                        modalDialog.style.height = '100px';
                        modalDialog.style.padding = '20px';
                        modalDialog.style.borderWidth = '2px';
                        modalDialog.style.borderStyle = 'solid';
                        modalDialog.style.borderColor = '#025B80';
                        modalDialog.style.backgroundColor = '#FFFFFF';
                        modalDialog.style.overflow = 'auto';

                        modalText.innerHTML = '<p>' + _text + '</p>';
                        modalText.style.backgroundColor = '#FFFFFF';
                        modalText.style.overflow = 'auto';
                        modalText.style.wordWrap = 'normal';

                        // Steal the loading animation.
                        modalIndicator.style.position = 'absolute';
                        modalIndicator.style.top = '50%';
                        modalIndicator.style.textAlign = 'center';
                        modalIndicator.style.width = '98%';
                        modalIndicator.style.height = '30px';
                        modalIndicator.style.backgroundColor = '#FFFFFF';
                        modalIndicator.style.borderRadius = '50%';
                        modalIndicator.style.display = 'inline-block';
                        modalIndicator.style.webkitAnimationName = 'bounce';
                        modalIndicator.style.webkitAnimationDirection = '0.6s';
                        modalIndicator.style.webkitAnimationIterationCount = 'infinite';
                        modalIndicator.style.webkitAnimationDirection = 'normal';

                        // modalDialog.appendChild(modalIndicator);
                        modalDialog.appendChild(modalText);
                        modal.appendChild(modalDialog);
                        document.body.appendChild(modal);
                        // IN-BROWSER-END
                    }, text).then(resolve, reject);
                } else {
                    resolve();
                }
            });
        },

        getLogs: function () {
            var me = this,
                driver = me.driver,
                logItems, logMessage, message;

            if (!me.logPromise && me.LOGS_SUPPORTED) {
                me.logPromise = driver.log('browser').then(function (logs) {
                    me.logPromise = null;
                    logItems = logs.value;
                    logItems.forEach(function (log) {
                        logMessage = log.message;
                        if (me.msgRE.test(logMessage)) {

                            /** Log Detection
                             *  We have to do some logging-type detection
                             * Chrome logs thusly:
                             * console-api 141:16 "STM:{\"to\":\"runner\",\"type\":\"recordingStarted\",\"seq\":1}"
                             * Embedded logs thusly:
                             * console-api 142:17 STM:{"to":"runner","type":"recordingStarted","seq":1}
                             */
                            if (logMessage.indexOf('"STM:') !== -1) {
                                // Start with Chrome detection
                                // Found Chrome log type
                                logMessage = JSON.parse(logMessage.substr(logMessage.indexOf('"STM:')));
                                message = JSON.parse(logMessage.substr(logMessage.indexOf('STM:') + 4));
                            } else {
                                message = JSON.parse(logMessage.substr(logMessage.indexOf('STM:') + 4));
                            }
                            if (message.to === 'runner') {
                                ST.sendMessage(message);
                            } else if (message.to !== 'sandbox') {
                                debugger;
                            } else {
                                if (message.type === 'navigate') {
                                    if (me.isRecording) {
                                        me._loadST().then(function () {
                                            me.startRecording();
                                        }, function (err) {
                                            // Problem loading ST
                                            if (ST.LOGME) console.log('==========> problem after naviagtion');
                                            me.handleClientError(err);
                                        }).catch(function (err) {
                                            // Problem starting recorder
                                            me.handleClientError(err);
                                        });
                                    }
                                }
                            }
                        } else if (me.hbRE.test(log)) {
                            if (ST.LOGME) console.log('WebDriver.getLogs: got heartbeat message');
                            // TODO update lastheartbeattime thingamabob
                        } else {
                            me.targetLogs.push(log);
                        }
                    });
                    me.logTargetConsole();
                    // TODO determine failure threshold(s), execute either an ST reload or utter failure back to Studio
                    // Need to use the heartbeating bits to determine connectivity to target browser before full failure
                }, function (err) {
                    if (ST.LOGME) console.log('WebDriver.getLogs: Log retrieval failed.', err);
                    me.handleClientError(err);
                }).catch(function (err) {
                    me.handleClientError(err);
                });
            }

            return me.logPromise;

            // TODO: error handling of log polling...
            // error when browser quits in selenium log:
            // Unable to evaluate script: disconnected: not connected to DevTools
            // but that error isn't returned in the driver log response... boo
        },

        handleClientError: function (error) {
            // init handles webdriver launch errors, so we want to know when something happened.
            // maybe we don't care if the target went away and should just stop whatever Studio was doing.
            if (error.type === 'NoSessionIdError') {
                // Target browser went away
                // TODO send message to Studio?
            } else if (error.type === 'RuntimeError') {
                if (error.seleniumStack) {
                    if (error.seleniumStack.status === '6') {
                        // Target browser went away
                        // TODO send message to Studio?
                    }
                }
            } else {
                debugger;
            }
        },

        logTargetConsole: function () {
            var me = this,
                logItems = me.targetLogs;

            if (!me.logPromise) {
                me.targetLogs = [];

                if (logItems.length) {
                    logItems.forEach(function (log) {
                        if (ST.LOGME) {
                            console.log(ST.LOGME+': '+log.message);
                            ST.sendMessage({
                                type: 'targetLog',
                                message: ST.LOGME+': '+log.message
                            });
                        }
                    });
                }
            }
        },

        pollLogs: function () {
            var me = this;

            if (!me.logTimer && me.LOGS_SUPPORTED) {
                me.logTimer = setInterval(function () {
                    me.getLogs();
                }, me.logPollInterval);
            }
        },

        startTargetHeartbeat: function () {
            var me = this,
                driver = me.driver;

            driver.execute(function (_heartbeatInterval) {
                // IN-BROWSER-BEGIN
                ST.defaultContext.startHeartbeat(_heartbeatInterval);
                // IN-BROWSER-END
            }, me.heartbeatInterval).catch(function (err) {
                // TODO couldn't start the heartbeat, probably should fallback to Studio
                if (ST.LOGME) console.log('Something happened on the way to heartbeat.', err);
                me.handleClientError(err);
            });
        },

        inject: function (playable, resolve, reject) {
            var me = this,
                type = playable.type,
            // for tap/focus/others... target could be me.locator and take care of this?
                webElement = playable.webElement || playable.future.webElement; // TODO how to resolve this?

            if (DEBUG_ME) debugger

            if (!ST.playable.Playable.isRemoteable(playable)) {
                // if an event is not remoteable and it isn't one of the below then
                // it is likely a wait(<milliseconds>) call or similar.
                // debugger
            }

            // use resolve/reject functions provided to complete any webdriver API calls...
            // NOTE: playable.targetEl is a WebJSON Element, so use .ELEMENT to provide the ID to JSONWire protocol
            // methods below...
            if (type === 'tap' || type === 'click') {
                // if locator is simple then just leftClick with x,y
                // if locatorChain, then first locate it... mark it in the target browser with a unique class
                // then leftClick x,y based on the unique class
                me.driver.elementIdClick(webElement.ELEMENT).then(resolve,reject);
            } else if (type === 'type') {
                // TODO support args.caret
                var text = playable.args.text || playable.text,
                    key = playable.args.key || playable.key,
                    caret = playable.args.caret || playable.caret; // TODO

                text = text || key;
                if (text === 'Backspace') {
                    text = String.fromCharCode(8);
                } else if (text === 'Delete') {
                    text = String.fromCharCode(46); // ???
                }

                me.driver.elementIdValue(webElement.ELEMENT, text).then(resolve,reject);
            } else if (playable.type && playable.type !== 'wait') {
                resolve();
                // TODO what else? keypress/keydown/...???
            } else {
                resolve();
            }
        },

        _remoteCallFn: function (playable, serialized, retry) {
            if (ST.LOGME) console.log('_remoteCallFn() serialized=',serialized);
            var me = this,
                driver = me.driver,
                ser = serialized;

            return new Promise(function (resolve, reject) {
                var start = new Date().getTime();

                if (DEBUG_ME) {
                    driver.timeouts('script', 30 * 60 * 1000); // 30 minute debug session?! ;)
                }

                driver.executeAsync(function (event, debug, remoteDone) {
                    // IN-BROWSER-BEGIN
                    if (typeof ST === 'undefined') {
                        remoteDone({
                            loadST: true
                        });
                        throw('ST_NEED_ST_EXCEPTION');
                    }

                    if (ST.LOGME) console.log('callFn, event=',event);

                    ST.DEBUG = debug;

                    window.$ST = window.$ST || {};
                    window.$ST.call = function () {
                        if (ST.DEBUG) debugger

                        var playable = ST.defaultContext.createPlayable(event),
                            future = playable.future,
                            promise, start;

                        start = new Date().getTime();

                        if (typeof playable.fn !== 'function') {
                            // alert('event.fn is not a function!? debug me!');
                            // debugger
                        }

                        var localDone = function (result) {
                            var retValue = {
                                playable: {
                                    webElement: playable.targetEl && playable.targetEl.dom
                                },
                                future: {
                                    webElement: future.el && future.el.dom
                                },
                                data: playable.future.data,
                                locatorWebElement: future.locator && future.locator.targetEl && future.locator.targetEl.dom,
                                duration: new Date().getTime() - start
                            };
                            retValue.timeout = result && result.timeout;

                            remoteDone(retValue);
                        };

                        promise = playable.fn.call(playable, localDone);

                        if (promise && typeof promise.then === 'function') {
                            promise.then(function () {
                                localDone();
                            });
                            // TODO handle reject case?
                        } else if (!playable.fn.length) {
                            localDone();
                        }
                    };

                    window.$ST.call();
                    // IN-BROWSER-END
                }, ser, DEBUG_ME).then(function (ret) {
                    if (ST.LOGME) console.log('callFn remote ret=',ret);
                    // me.getTargetConsoleLog();
                    if (DEBUG_ME) debugger

                    if (ST.options.webdriverPerf) {
                        ST.status.addResult({
                            passed: true,
                            message: 'WebDriver._remoteCallFn.browser.duration.'+playable.type+'='+ret.value.duration
                        });
                        ST.status.addResult({
                            passed: true,
                            message: 'WebDriver._remoteCallFn.sandbox.duration.'+playable.type+'='+(new Date().getTime()-start)
                        });
                    }

                    var v = ret.value,
                        loadST = v.loadST;

                    if (loadST && retry) {
                        me._loadST().then(function () {
                            me._remoteCallFn(playable, ser, false).then(resolve, reject);
                        }, reject);
                    } else {
                        {
                            ST.apply(playable, v.playable); // apply targetDom because it might have been reconstructed
                            ST.apply(playable.future, v.future);
                            if (v.data && playable.future) {
                                playable.future.setData(v.data);
                            }
                            if (v.locatorWebElement) {
                                playable.future.locator.webElement = v.locatorWebElement;
                            }
                            

                            resolve(ret.value);
                        }
                    }
                }, function (err) {
                    if (ST.LOGME) console.log('callFn remote, err=',err);
                    // me.getTargetConsoleLog();
                    if (DEBUG_ME) debugger

                    // TODO is err.seleniumStack documented and stable?
                    if (err.seleniumStack && err.seleniumStack.type === 'StaleElementReference') {
                        // force a new lookup TODO would be better if it didn't blow
                        // all the way back up to our sandbox side!??!
                        playable.webElement = undefined;
                        playable.future.webElement = undefined;
                        // TODO retry instead...
                        reject(); // TODO really want to cause a "ready()" call to happen so we re-find the element...

                        // TODO QUESTION>>> do we want the locators to "fix" themselves on page navigations/reloads???
                        // or should the test writer have to re-find since they should know when a reload/nav occurs???
                        return;
                    }

                    reject(err);
                }).catch(function (err) {
                    if (ST.LOGME) console.log('callFn remote catch err=', err);
                });
            });
        },

        callFn: function (playable, done) {
            var me = this,
                serialized = me._serialize(playable);

            if (DEBUG_ME) debugger

            if (ST.playable.Playable.isRemoteable(playable)) {
                return me._remoteCallFn(playable, serialized, true); // one retry
            } else {
                return playable.fn.call(playable, done);
            }
        },

        _serialize: function (playable) {
            // TODO pare this down as much as possible!!! for performance
            var ret = {};

            for (var i in playable) {
                var t = typeof playable[i];
                var v = playable[i];

                if (t !== 'object' && t !== 'function') {
                    ret[i] = v;
                }
                if (t === 'object' && v === null) { // TODO for what? webElement?
                    ret[i] = v;
                }
            }

            // TODO will targetReady translate playable.targetEl (dom) into an ST.Element?
            ret.webElement = playable.webElement;

            if (playable.target) {
                if (typeof playable.target === 'string') {
                    ret.target = playable.target;
                } else {
                    ret.target = {};
                    ret.target.webElement = playable.target.webElement;
                    ret.target.locatorChain = playable.target.locatorChain;
                    // TODO what else??? do we need from target = me.locator?
                }
            }

            // TODO take relatedCmps, strip out their webElement and send that instead...

            ret.future = ret.future || {};
            ret.futureData = ST.apply({}, playable.instanceData);
            if (playable.future) {
                var retf = ret.future,
                    future = playable.future,
                    related = future.related;

                retf.related = {};

                for(var name in related) {
                    var relatedFuture = related[name];
                    retf.related[name] = {
                        webElement: relatedFuture.webElement,
                        futureClsName: relatedFuture.$className,
                        data: relatedFuture.data
                    };
                }

                // TODO other types of locators other than Playable?
                if (future.locator) {
                    retf.locator = {
                        webElement: future.locator.webElement,
                        locatorChain: future.locator.locatorChain
                    };
                }
                
                retf.locatorChain = ret.root = future.locatorChain;
                retf.webElement = future.webElement;
                ret.futureClsName = future.$className;
                retf.data = future.data;
                retf.futureData = future.futureData; // don't EVER send futureData... could be too big??? might need a sendData on the future?
            }

            ret.args = playable.args; // TODO maybe a replacement or augmentation for instanceData?
            ret.instanceData = playable.instanceData;

            return ret;
        },

        // TODO big TODO for performance... only send over changes to futures/playables... :(
        _remoteReadyFn: function (playable, serialized, retry) {
            if (ST.LOGME) console.log('_remoteReadyFn() serialized=',serialized);
            var me = this,
                driver = me.driver,
                ser = serialized;

            return new Promise(function (resolve,reject) {
                var start = new Date().getTime();

                if (DEBUG_ME) {
                    driver.timeouts('script', 30 * 60 * 1000);
                }

                // TODO refactor these methods called by executeAsync as LocalWebDriver methods!
                // make things easier to read? ;) And easier to understand where things are?

                driver.executeAsync(function (event, debug, done) {
                    var start = new Date().getTime();

                    // IN-BROWSER-BEGIN
                    if (typeof ST === 'undefined') {
                        done({ loadST: true });
                    }

                    ST.DEBUG = debug;

                    window.$ST = window.$ST || {};
                    window.$ST.ready = function () {
                        if (ST.DEBUG) debugger

                        var playable = ST.defaultContext.createPlayable(event),
                            future = playable.future,
                            ready = false;

                        try {
                            ready = playable.ready();
                        } catch (e) {
                            if (ST.DEBUG) debugger
                            done({
                                error: e.message,
                                duration: new Date().getTime() - start
                            });
                            return;
                        }

                        done({
                            playable: {
                                webElement: playable.targetEl && playable.targetEl.dom,
                                // webElement: playable.targetEl && playable.targetEl.dom,
                                waitingFor: playable.waitingFor,
                                waitingState: playable.waitingState
                            },
                            future: {
                                webElement: future.el && future.el.dom
                            },
                            data: future.data,
                            ready: ready,
                            duration: new Date().getTime() - start
                        });
                    };

                    window.$ST.ready();
                    // IN-BROWSER-END
                }, ser, DEBUG_ME).then(function (ret) {

                    if (ST.LOGME) console.log('ready remote call playable.type='+playable.type+', ret=',ret);

                    if (ST.options.webdriverPerf) {
                        // TODO make a SINGLE result that can be appended to to contain all the perf data :)
                        ST.status.addResult({
                            passed: true,
                            message: 'WebDriver._remoteReadyFn.browser.duration.'+playable.type+'='+ret.value.duration
                        });
                        ST.status.addResult({
                            passed: true,
                            message: 'WebDriver._remoteReadyFn.sandbox.duration.'+playable.type+'='+(new Date().getTime()-start)
                        });
                    }

                    if (DEBUG_ME) debugger

                    var v = ret.value,
                        ready = v.ready,
                        error = v.error,
                        loadST = v.loadST;

                    if (loadST && retry) {
                        me._loadST().then(function () {
                            me._remoteReadyFn(playable, ser, false).then(resolve, reject);
                        }, reject);
                    } else if (error) {
                        reject(error);
                    } else {
                        ST.apply(playable, v.playable);
                        ST.apply(playable.future, v.future);
                        if (v.data && playable.future) {
                            playable.future.setData(v.data);
                        }

                        ready ? resolve(ret) : reject();
                    }
                }, function (err) {
                    if (ST.LOGME) console.log('ready remote call, playable.type='+playable.type+', err=',err);
                    // me.getTargetConsoleLog();
                    if (DEBUG_ME) debugger

                    // TODO is this documented?!??!?! STABLE???
                    if (err.seleniumStack && err.seleniumStack.type === 'StaleElementReference') {
                        // force a new lookup TODO would be better if it didn't blow
                        // all the way back up to our sandbox side!??!
                        playable.webElement = undefined;
                        playable.future.webElement = undefined;
                        reject();
                        return;
                    }

                    if (retry) {
                        me._loadST().then(function () {
                            me._remoteReadyFn(playable,ser,false).then(resolve,reject);
                        }, reject);
                    } else {
                        reject(err);
                    }
                }).catch(function (err) {
                    // me.getTargetConsoleLog();
                    if (ST.LOGME) console.log('ready remote executeAsync catch, playable.type='+playable.type+', err='+err);
                });
            });
        },

        // TODO if we switched pages or for some reason ANY of the webElements we rely on
        // then _remoteReadyFn will REJECT which causes a bit of trouble...
        // NUCLEAR SOLUTION: stop using webElement and build our own which doesn't blow up an execute call
        // INTERIM: recover nicely by nulling out the webElements and retry the _remoteReadyFn()
        ready: function (playable, resolve, reject) {
            var me = this,
                serialized = me._serialize(playable);

            if (ST.playable.Playable.isRemoteable(playable)) {
                me._remoteReadyFn(playable, serialized, true /* one retry */).then(resolve, reject);
            } else {
                resolve();
            }
        },

        _checkGlobalLeaks: function (done, contextGlobals, retry) {
            if (ST.LOGME) console.log('WebDriver._checkGlobalLeaks()');
            var me = this,
                driver = me.driver,
                contextGlobals = contextGlobals || ST.options.contextGlobals;

            if (typeof retry === 'undefined') {
                retry = true;
            }

            driver.executeAsync(function (debug, contextGlobals, done) {
                if (typeof ST === 'undefined') {
                    done({ loadST: true });
                    return;
                }

                ST.DEBUG = debug;

                window.$ST = window.$ST || {};
                window.$ST.check = function () {
                    try {
                        var result;

                        if (ST.DEBUG) debugger

                        ST.addGlobals.apply(ST,contextGlobals);

                        result = ST.checkGlobalLeaks();
                        done({
                            result: result
                        });
                    } catch (e) {
                        done({
                            error: e.message || e
                        });
                    }
                };

                window.$ST.check();

            }, DEBUG_ME, contextGlobals).then(function (ret) {
                var value = ret.value,
                    loadST = value.loadST,
                    result = value.result,
                    error = value.error;

                if (DEBUG_ME) debugger



                if (loadST && retry) {
                    me._loadST().then(function () {
                        me._checkGlobalLeaks(done, contextGlobals, false);
                    }, function (err) {
                        done({
                            results: [{
                                passed: false,
                                message: 'Global leaks check threw an error: ' + (err || err.message)
                            }]
                        });
                    });
                    return;
                }

                // NOTE: done must return what Base.checkGlobalLeaks expects, currently:
                // { results: [<expectations results>], addedGlobals: [<string property names>] }
                if (result) {
                    done(result);
                } else if (error) {
                    done({
                        results: [{
                            passed: false,
                            message: 'Global leaks check threw an error: ' + error
                        }]
                    });
                } else {
                    done({
                        results: [{
                            passed: false,
                            message: 'Global leaks check returned no results or error.'
                        }]
                    });
                }
            },function (err) {
                if (DEBUG_ME) debugger
                done({
                    results: [{
                        passed: false,
                        message: 'Global leaks check threw an error: ' + err.message || err
                    }]
                });
            });
        },

        _loadST: function () {
            if (ST.LOGME) console.log('WebDriver._loadST()');

            var me = this,
                driver = me.driver,
                promises = [],
                files = [],
                errors = [];

            return new Promise(function (resolve, reject) {
                me.displayModal().then(function (ret) {

                    for (var file in me._STContent) {
                        files.push(file);
                    }

                    var _load = function (i) {
                        // exit recursion
                        if (i > files.length - 1) {
                            if (errors.length > 0) {
                                reject(errors);
                            } else {
                                // this is sort of an init() for the ST stuff...
                                // check on Ext readiness
                                // setup globals
                                // more ???
                                // If for some reason ST isn't there just let it throw an error
                                var tmpOptions = {};
                                ST.apply(tmpOptions, ST.options);
                                // clear out globals and globalPatterns since we let the target manage it's own.
                                tmpOptions.globalPatterns = {};
                                tmpOptions.globals = {};
                                
                                me.driver.executeAsync(function (testOptions, done) {
                                    ST.setupOptions(testOptions); // results in ST.initGlobals() being called.

                                    if (Ext && Ext.onReady) { // this is an ext page
                                        if (ST.LOGME) console.log('setup Ext.onReady callback');


                                        Ext.onReady(function () {
                                            if (ST.LOGME) console.log('Ext.onReady callback is called');

                                            ST.initExtJS(); // in case the _beforereadyhandler didn't fire
                                            // and the delayed call didn't fire at the right time either.

                                            if (ST.LOGME) console.log('after initExtJs called, ST.ready.blocks=' + ST.ready.blocks);

                                            done();
                                        });
                                    } else {
                                        if (ST.LOGME) console.log('no Ext and Ext.onReady so assume NOT an ext page and return');

                                        done(); // this is a non ext page
                                    }
                                }, tmpOptions).then(resolve, reject);
                            }
                            return;
                        }

                        var file = files[i],
                            content = me._STContent[file];

                        driver.executeAsync(function (file, content, done) {
                            // IN-BROWSER-BEGIN
                            var insert = function () {
                                try {
                                    var script = document.createElement('script');
                                    script.innerHTML = content;
                                    script.setAttribute('file', file);
                                    document.body.appendChild(script);

                                    done({
                                        file: file,
                                        loaded: true
                                    });
                                } catch (e) {
                                    done({
                                        file: file,
                                        error: e
                                    });
                                }
                            };

                            if (document.readyState === 'complete') {
                                insert();
                            } else {
                                document.addEventListener('readystatechange', function () {
                                    if (document.readyState === 'complete') {
                                        insert();
                                    }
                                });
                            }
                            // IN-BROWSER-END
                        }, file, content)
                            .then(function (ret) {
                                if (ret.value && ret.value.loaded) {
                                    if (ST.LOGME) console.log('LOADED script:' + ret.value.file);
                                    _load(i + 1);
                                    // resolve(ret.value);
                                } else {
                                    if (ST.LOGME) console.log('script:' + ret.value.file + ', appendChild error=', error);
                                    errors.push(ret.value);
                                    reject(errors); // fail fast!?
                                    // reject(ret.value);
                                }
                            }, function (err) {
                                if (ST.LOGME) console.log('script:' + file + ', execution err='+JSON.stringify(err));
                                reject(err);
                            });
                    };

                    _load(0); // start the recursion

                });
            });
        },

        // TODO cleanup/onStop/onEnd only needed for ST.context.Local for Injector
        cleanup: function () {
            if (ST.LOGME) console.log('WebDriver cleanup()');
            //TODO
        },

        // NOTE: called from testRunFinished, all tests have run... close the browser.
        onStop: function (resolve, reject) {
            var me = this, logPromise;

            if (ST.LOGME) console.log('WebDriver onStop()');
            if (ST.LOGME) console.trace();

            if (!me.isRecording) {
                if (me.driver && me.LOGS_SUPPORTED) {
                    me.logTimer && clearInterval(me.logTimer);
                    logPromise = me.getLogs();
                    logPromise.then(function (ret) {
                        if (ST.LOGME) console.log('WebDriver.onStop, logPromise resolve, call driver.end(), ret=',ret);
                        me.driver.end().then(resolve, reject);
                    }, function (err) {
                        if (ST.LOGME) console.log('WebDriver.onStop, logPromise reject, call driver.end(), err=',err);
                        me.driver.end().then(resolve, reject);
                    });
                } else {
                    if (ST.LOGME) console.log('WebDriver.onStop, no logPromise, call driver.end(), err=',err);
                    me.driver.end().then(resolve, reject);
                }
            }
        },

        // TODO config on scenario/project about when to start a new browser instance
        onEnd: function (resolve) {
            if (ST.LOGME) console.log('WebDriver onEnd()');
            if (ST.LOGME) console.trace();
            resolve();
        },

        startRecording: function () {
            var me = this,
                driver = me.driver;

            me.isRecording = true;

            driver.execute(function () {
                // IN-BROWSER-BEGIN
                ST.defaultContext.startRecording();
                // IN-BROWSER-END
            }).then(function (ret) {
                    if (ST.LOGME) console.log('WebDriver.startRecording: recorder started in target browser.');
            },
                function (err) {
                    // TODO handle recorder errors
                    if (ST.LOGME) console.log('WebDriver.startRecording: Problem loading ST.', err);
            });
        },

        stopRecording: function () {
            var me = this,
                driver = me.driver;

            if (driver) {
                if (me.isRecording) {
                    me.isRecording = false;
                    ST.sendMessage('recordingStopped');
                }
                driver.end();
            }
        },

        // TODO config-ify webdriver pass-through functions?
        webdriverPassThroughs : ['getUrl','getTitle'],

        // sort of like execute in webdriver API but different because
        // fn's scope is the playable
        // fn gets passed the future/future._value(), whichever is available
        execute: function (playable, fn, resolve, reject, retry) { // optional done?
            var me = this,
                driver = me.driver,
                ser = me._serialize(playable);

            if (typeof retry === 'undefined') {
                retry = true;
            }

            driver.executeAsync(function (event, fnstring, debug, done) {
                // IN-BROWSER-BEGIN
                if (typeof ST === 'undefined') {
                    done({
                        loadST: true
                    });
                    return;
                }

                ST.DEBUG = debug;

                window.$ST = window.$ST || {};
                window.$ST.exec = function () {
                    if (ST.DEBUG) debugger

                    eval('var fn = '+fnstring);

                    var playable = ST.defaultContext.createPlayable(event),
                        future = playable.future,
                        value = future._value(),
                        result;

                    try {
                        result = fn.call(playable, value);
                        done({
                            result: result
                        });
                    } catch (e) {
                        done({
                            error: e.message || e
                        });
                    }
                };

                window.$ST.exec();
                // IN-BROWSER-END
            }, ser, fn.toString(), DEBUG_ME).then(function (ret) {
                if (DEBUG_ME) debugger
                if (ret.value && ret.value.error) {
                    reject(ret.value.error);
                } else if (ret.value.loadST) {
                    me._loadST().then(function () {
                        me.execute(playable, fn, resolve, reject, false);
                    }, reject);
                } else {
                    resolve(ret.value.result);
                }
            }, function (err) {
                if (DEBUG_ME) debugger
                reject(err);
            });
        },

        getUrl: function (fn) {
            this.driver.getUrl().then(fn);
        },

        getTitle: function (fn) {
            this.driver.getTitle().then(fn);
        },

        url: function (url, done) {
            var isFragment;

            url = new ST.Url(url);
            done = typeof done === 'function' ? done : ST.emptyFn;
            isFragment = url.isOnlyHash();
            url = isFragment ? url.getHash() : url.get();

            this.driver.execute(function (url, isFragment) {
                if (isFragment) {
                    window.location.hash = url;
                } else {
                    window.location = url;
                }                
            }, url, isFragment).then(done);
        },
        
        _screenshot: function (name, done) {
            var me = this,
                senchaCfg = me.driverConfig.desiredCapabilities.sencha,
                driver = me.driver,
                promise;

            return driver.saveScreenshot(function (err, screenshot, response) {
                if (err) {
                    return Promise.reject(err);
                } else {
                    return me._compareScreenshot(name, me._arrayBufferToBase64(screenshot));
                }
            }).then(function (comparison) {
                done(null, comparison);
            }, function (err) {
                done(err, null);
            });
        },
        
        _arrayBufferToBase64: function (buffer) {
            var binary = '',
                bytes = new Uint8Array(buffer),
                len = bytes.byteLength,
                i;
            
            for (i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            
            return window.btoa(binary);
        },
        
        _compareScreenshot: function (name, base64Png) {
            var me = this;
            return new Promise(function (resolve, reject) {
                ST.system.screenshot({
                    data: base64Png,
                    name: name
                }, function (comparison, err) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(comparison);
                    }
                });
            })
        }
    });

}()) // scope for DEBUG_ME - file scope

