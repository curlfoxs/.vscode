'use strict';

var Base = require('../Base'),
    Image = require('./Image');

class Comparator extends Base {

    constructor(cfg) {
        super();
        var me = this;
        Object.assign(me, {
            errorColor: {
                red: 255,
                green: 0,
                blue: 255
            },
            transparency: 0.3,
            mask: 0xff
        });
        Object.assign(me, cfg);
    }


    compare (expected, actual) {
        expected = expected.isImage ? expected : new Image(expected);
        actual = actual.isImage ? actual : new Image(actual);
        var me = this;

        return new Promise(function(resolve, reject) {
            //var t0 = new Date().getTime();
            var actualData = null,
                expectedData = null,
                expectedLoaded = false,
                actualLoaded = false,
                comparator = function() {
                    if (actualData && expectedData) {
                        try {
                            //var t1 = new Date().getTime();
                            var width = Math.max(expected.width, actual.width),
                                height = Math.max(expected.height, actual.height),
                                diff = new Image({
                                    width: width,
                                    height: height
                                }),
                                buff = diff.data;

                            var diffCount = 0,
                                diffRed = me.errorColor.red,
                                diffGreen = me.errorColor.green,
                                diffBlue = me.errorColor.blue,
                                alpha = me.transparency,
                                mask = me.mask,
                                line, col,
                                ep, ap, bp, eOffset, aOffset, bOffset, delta,
                                epr, epg, epb, epa,
                                apr, apg, apb, apa,
                                bpr, bpg, bpb, bpa,
                                er, eb, eg, ea,
                                dr, db, dg, da;
                            
                            for (line = 0; line < height; line++) {
                                for (col = 0; col < width; col++) {
                                    ep = (line * expected.width) + col;
                                    ap = (line * actual.width) + col;
                                    bp = (line * width) + col;

                                    bOffset = bp * 4;
                                    bpr = bOffset + 0;
                                    bpg = bOffset + 1;
                                    bpb = bOffset + 2;
                                    bpa = bOffset + 3;
                                    
                                    if (col < expected.width
                                            && col < actual.width
                                            && line < expected.height
                                            && line < actual.height) {
                                        eOffset = ep * 4;
                                        epr = eOffset + 0;
                                        epg = eOffset + 1;
                                        epb = eOffset + 2;
                                        epa = eOffset + 3;
                                        
                                        aOffset = ap * 4;
                                        apr = aOffset + 0;
                                        apg = aOffset + 1;
                                        apb = aOffset + 2;
                                        apa = aOffset + 3;
                                        
                                        er = expectedData[epr];
                                        eg = expectedData[epg];
                                        eb = expectedData[epb];
                                        ea = expectedData[epa];
        
                                        dr = er - actualData[apr];
                                        dg = eg - actualData[apg];
                                        db = eb - actualData[apb];
                                        da = ea - actualData[apa];
                                        
                                        buff[bpr] = er;
                                        buff[bpg] = eg;
                                        buff[bpb] = eb;
                                        buff[bpa] = ea * alpha;
                                    } else {
                                        dr = dg = db = da = 255;
                                    }
    
                                    delta = dr | dg | db | da;
    
                                    // if any of the previous values have a bit set,
                                    // then we need to verify against the current mask
                                    // whether this is an actual difference.  however, if
                                    // there a no bits set, then this is already a match
                                    if (delta) {
                                        dr = dr < 0 ? -dr : dr;
                                        dg = dg < 0 ? -dg : dg;
                                        db = db < 0 ? -db : db;
                                        da = da < 0 ? -da : da;
                                        delta = (dr & mask) | (dg & mask) | (db & mask) | (da & mask);
                                        if (delta) {
                                            diffCount++;
                                            buff[bpr] = diffRed;
                                            buff[bpg] = diffGreen;
                                            buff[bpb] = diffBlue;
                                            buff[bpa] = 255;
                                        }
                                    }
                                }
                            }

                            diff.diffCount = diffCount;
                            //var t2 = new Date().getTime();
                            //console.log('Load Time : ' + (t1 - t0) + ' msec.');
                            //console.log('Diff Time : ' + (t2 - t1) + ' msec.');
                            //console.log('Comp Time : ' + (t2 - t0) + ' msec.');
                            resolve(diff);
                        } catch (err) {
                            reject(err);
                        }
                    }
                    else if (expectedLoaded && actualLoaded) {
                        reject('Failed to load files');
                    }
                };

            expected.load().then(function () {
                expectedData = expected.data;
                expectedLoaded = true;
                comparator();
            }).catch(function(err){
                reject(err);
            });

            actual.load().then(function(){
                actualData = actual.data;
                actualLoaded = true;
                comparator();
            }).catch (function(err) {
                reject(err);
            });

        });
    }

}

module.exports = Comparator;
