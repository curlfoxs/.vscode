'use strict';

const Base = require('orion-core/lib/Base');
const ChildProcessTask = require('orion-core/lib/tasks/ChildProcessTask');
const Util = require('orion-core/lib/Util');
const xfs = require('orion-core/lib/xfs');
const ProcessUtil = require('orion-core/lib/process/ProcessUtil');

const path = require('path');

class SelfSpawner extends Base {

    static get meta() {
        return {
            mixinId: 'selfSpawner'
        };
    }
    
    ctor () {
        var me = this,
            parentDir = path.join(__dirname, '..'),
            execPath = process.execPath,
            isCommandLine,
            isProduction,
            isStudio = false,
            hasStudioExecutable = false,
            params = [],
            task,
            cwd;
        
        if (execPath.endsWith('Sencha Studio.exe') || execPath.endsWith('Sencha Studio Helper') || execPath.endsWith('Launcher')) {
            // Studio in production
            isCommandLine = false;
            isProduction = true;
            hasStudioExecutable = true;
        } else if (execPath.endsWith('electron.exe') || execPath.endsWith('Electron Helper') || execPath.endsWith('electron')) {
            // Studio in development
            isCommandLine = false;
            isProduction = false;
        } else if (execPath.endsWith('node.exe') || execPath.endsWith('node') || execPath.endsWith('nodejs')) {
            // Command line in production or development
            isCommandLine = true;
            isProduction = null; // we don't know, it can be both
        } else {
            // Worst case assume Studio in production
            isCommandLine = false;
            isProduction = true;
        }
        
        // debug
        // execPath += '-debug';
        // debug
        
        if (isCommandLine) {
            let stcDir = path.join(process.mainModule.filename, '..');
            let orionDir = path.join(stcDir, '..');
            
            if (Util.isMac) {
                if (xfs.existsSync(path.join(stcDir, 'Electron.app'))) {
                    execPath = path.join(stcDir, 'Electron.app', 'Contents', 'MacOS', 'Electron');
                    isProduction = true;
                } else if (xfs.existsSync(path.join(orionDir, 'Sencha Studio.app'))) {
                    execPath = path.join(orionDir, 'Sencha Studio.app', 'Contents', 'MacOS', 'Sencha Studio');
                    isProduction = true;
                    hasStudioExecutable = true;
                }
            } else if (Util.isWin) {
                if (xfs.existsSync(path.join(stcDir, 'electron.exe'))) {
                    execPath = path.join(stcDir, 'electron.exe');
                    isProduction = true;
                } else if (xfs.existsSync(path.join(orionDir, 'Sencha Studio.exe'))) {
                    execPath = path.join(orionDir, 'Sencha Studio.exe');
                    isProduction = true;
                    hasStudioExecutable = true;
                }
            } else if (Util.isLinux) {
                if (xfs.existsSync(path.join(stcDir, 'electron'))) {
                    execPath = path.join(stcDir, 'electron');
                    isProduction = true;
                } else if (xfs.existsSync(path.join(orionDir, 'Launcher'))) {
                    execPath = path.join(orionDir, 'Launcher');
                    isProduction = true;
                    hasStudioExecutable = true;
                }
            }
            
            if (!isProduction) {
                execPath = require('electron');
            }
        }
        
        if (!isCommandLine && Util.isMac) {
            if (isProduction) {
                let helperPath = '/Frameworks/Sencha Studio Helper.app/Contents/MacOS/Sencha Studio Helper'
                let binPath = '/MacOS/Sencha Studio';
                execPath = execPath.replace(helperPath, binPath);
            } else {
                let helperPath = '/Frameworks/Electron Helper.app/Contents/MacOS/Electron Helper'
                let binPath = '/MacOS/Electron';
                execPath = execPath.replace(helperPath, binPath);
            }
        }
        
        if (Util.isWin) {
            execPath = xfs.normalize(execPath);
        }
        
        if (!hasStudioExecutable) {
            let modulePath;
            
            if (isCommandLine) {
                modulePath = path.join(process.mainModule.filename);
            } else {
                modulePath = path.join(process.mainModule.filename, '..', 'studio.js');
            }
            
            if (Util.isWin) {
                modulePath = xfs.normalize(modulePath);
            }
            
            params.push(modulePath);
        }
        
        params = params.concat(me.getSpawnSwitches());
        
        me._execPath = execPath;
        me._params = params;
    }
    
    getExecPath () {
        return this._execPath;
    }
    
    spawn () {
        var me = this,
            execPath = me._execPath,
            params = Util.clone(me._params), // ProcessUtil pokes params down the road
            opts = {
                stdio: Util.isLinux 
                    ? ['pipe', 'pipe', 'pipe', 'ipc']
                    : ['ipc', 'pipe', 'pipe']
            },
            cptConfig = {
                description: me.getChildProcessDescription(),
                executable: execPath,
                args: params,
                stdoutLevel: 'debug',
                opts: opts
            },
            task;
        
        if (Util.isWin) {
            cptConfig.launchProcess = function () {
                return ProcessUtil.spawn({
                    executable: execPath,
                    args: params,
                    options: opts
                })
            }
        }
        
        task = me.task = new ChildProcessTask(cptConfig);
        
        if (task.running) {
            me.onTaskRunning();
        } else {
            task.on('running', me.onTaskRunning.bind(me));
        }
            
        task.on('complete', me.onTaskComplete.bind(me));
        
        return task;
    }
    
}

module.exports = SelfSpawner;
