'use strict';

var Util = require('orion-core/lib/Util');
// Util.stacktrace();
// throw new Error();
var fs = require('fs');
var path = require('path');
var File = require('./fs/File');
var slashRe = /\\/g;
var os = require('os');
var uuid = require('uuid');

var xfs = {
    splitRe: /[/\\]/g,
    separator: File.separator,

    //session: uuid.v1(),
    session: 'session',
    homeDir: new File(os.homedir()),

    setTempDir (tmp) {
        var me = xfs;
        if (!tmp.$isFile) {
            tmp = new File(tmp);
        }
        me.tempDir = new File(tmp, 'Sencha-Studio');
        me.tempSessionDir = new File(me.tempDir, me.session);
        me.tempSessionDir.remove().then(function(data){
            me.tempSessionDir.ensurePathExists();
        });
        me.tempSessionDir.removeOnExit();
    },

    exists (path, callback) {
        if (typeof callback === 'function') {
            new File(path).exists().then(function(exists) {
                callback(exists);
            }).catch(function (err) {
                console.error(err.stack || err);
            });
        } else {
            return new File(path).exists();
        }
    },

    existsSync (path) {
        try {
            fs.accessSync(path, fs.F_OK);
            return true;
        } catch (err) {
            return false;
        }
    },

    normalize (path) {
        return (path || '').replace(slashRe, '/');
    },

    wrapError (fileName, error) {
       return File.wrapError(fileName, error);
    },

    dirList (fileName, recursive) {
        return new File(fileName).getFiles(recursive);
    },

    dirListSync (dir, recursive) {
        return new File(dir).getFilesSync(recursive);
    },

    listAllFilesSync (dir) {
        return xfs.dirListSync(dir, true);
    },

    isDirectory (fileName) {
        return new File(fileName).isDirectory();
    },

    isFile (fileName) {
        return new File(fileName).isFile();
    },

    join () {
        return File.join.apply(File, arguments);
    },

    flatten (pathstr) {
        return File.flatten(pathstr);
    },

    resolve () {
        return path.resolve.apply(path, arguments);
    },

    split (fileName) {
        return File.split(fileName);
    },

    getRelativePath (from, to) {
        return new File(from).relativeTo(to).path;
    },

    mkdir (dir) {
        return new File(dir).ensurePathExists();
    },

    writeFile (fileName, content, options) {
        return new File(fileName).write(content, options);
    },

    removeFile (fileName) {
        return new File(fileName).remove();
    },

    copy (source, target) {
        return new Promise(function(resolve, reject) {
            var called = false;

            function done(err) {
                if (!called) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve();
                    }
                    called = true;
                }
            }

            source = source + '';
            target = target + '';

            var rd = fs.createReadStream(source);
            rd.on("error", function(err) {
                done(err);
            });
            var wr = fs.createWriteStream(target);
            wr.on("error", function(err) {
                done(err);
            });
            wr.on("close", function(ex) {
                done();
            });
            rd.pipe(wr);
        });
    },

    rename (oldName, newName) {
        return new Promise(function(resolve, reject) {
            fs.rename(oldName, newName, function(err) {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    },

    readFile (path, options) {
        return new File(path).read(options);
    },

    setBinDir (dir, isProduction) {
        if (isProduction) {
            // Finding binDir, we expect app.js in resources.
            // (app.js is this file and thus __dirname)
            do {
                name = dir.name;
                dir = dir.parent;
            } while (name !== 'app.asar');

            if (Util.isMac) {
                dir = dir.parent.parent.parent; // <binDir>/Sencha Studio.app/Contents/Resources/app.asar
            } else {
                dir = dir.parent; // <binDir>/resources/app.asar/app.js
            }

            this.filesDir = dir;
        } else {
            this.filesDir = dir.join('files');
        }

        this.binDir = dir;
    }
};

xfs.setTempDir(os.tmpdir());

/**
 * Windows : C:\Users\username\.sencha\
 * Linux   : ~/.local/share/data/Sencha/
 * Mac     : ~/Library/Application Support/Sencha/
 * Other   : ~/.sencha
 */
xfs.profileDir = new File(function () {
    var ret = os.homedir();

    switch (os.platform()) {
        case 'win32':
            return xfs.join(process.env.USERPROFILE, '.sencha');

        case 'darwin':
            return xfs.join(ret, 'Library/Application Support/Sencha');

        case 'linux':
            return xfs.join(ret, '.local/share/data/Sencha');
    }

    return xfs.join(ret, '.sencha');
}());

xfs.seleniumDir = new File(function () {
    var profileDir = xfs.profileDir;
    // for selenium assets, we'll just add them to them to the root profile folder for Studio
    return xfs.join(profileDir.path, 'Studio', 'selenium');
}());

xfs.electronDir = new File(function () {
    var electronPath;

    try {
        // Studio running from source
        electronPath = require('electron');
    } catch (e) {
        // Studio running from binary
        electronPath = process.execPath;

        if (Util.isMac) {
            let helperPath = '/Frameworks/Sencha Studio Helper.app/Contents/MacOS/Sencha Studio Helper'
            let binPath = '/MacOS/Sencha Studio';
            electronPath = electronPath.replace(helperPath, binPath);
        }
    }
    return electronPath;
}());

module.exports = xfs;
