"use strict";

var Pool = require('orion-core/lib/model/farm/Pool');
var EmbeddedBrowser = require('orion-core/lib/model/browser/Embedded');
var Task = require('orion-core/lib/tasks/Task');
var ChildProcessTask = require('orion-core/lib/tasks/ChildProcessTask');
var xfs = require('orion-core/lib/xfs');
var Json = require('orion-core/lib/Json');
var webdriverio = require('webdriverio');
var Farm = require('./Farm');
var path = require('path');
var selenium = require('selenium-standalone');
var portfinder = require('portfinder');
var util = require('util');
var Util = require('orion-core/lib/Util');
var File = require('orion-core/lib/fs/File');
var fs = require('fs');

class Embedded extends Farm {
    
    static get meta () {
        return {
            prototype: {
                isPowerable: true
            }
        };
    }
    
    
    ctor () {
        var me = this,
            data = me.data;
        
        data.name = data.name || 'Embedded';
        data.type = data.type || 'embedded';
        data.host = data.host || 'localhost';
        
        // defaultSeleniumBasePath will be for future use, when user can set their own base path
        // this will be used to restore the default
        // right now, we should skip the configurability since we don't have a way to manage it from stc side yet...
        me.set('defaultSeleniumBasePath', xfs.seleniumDir);
        me.set('seleniumBasePath', xfs.seleniumDir);
    }
    
    driverConfig (browserData) {
        var cfg = super.driverConfig(browserData),
            caps = cfg.desiredCapabilities;

        if (caps.browserName === 'chromium') {
            caps.browserName = 'chrome';
        }
        
        return cfg;
    }

    get connectionDisplay () {
        return 'Embedded';
    }

    getSeleniumServerJarName (version) {
        // selenium-standalone expects jar name in following form: '{version}-server.jar' (e.g., 2.53.1-server.jar)
        return version + '-server.jar';
    }

    getChromeDriverName (version) {
        // selenium-standalone expects driver name in following form: '{version}-{arch}-chromedriver' (e.g., 2.23-x64-chromedriver)
        return version + '-' + process.arch + '-chromedriver';
    }
    
    get hubConfig () {
        var config = this.seleniumConfig ? this.seleniumConfig.hub || {} : {};

        config.seleniumArgs = ['--', '-role', 'hub'];
        
        return config;
    }

    get nodeConfig () {
        var config = this.seleniumConfig ? this.seleniumConfig.node || {} : {},
            basePath = this.get('seleniumBasePath').path;

        config.basePath = basePath;
        config.javaArgs = ['-Djava.util.logging.config.file=' + path.join(basePath, 'logging.properties')];

        return config;
    }

    _scaffoldSelenium (opts) {
        var me = this,
            needsInstall = false,
            config, seleniumPath, loggingPropertiesPath, jsonPath;

        seleniumPath = me.get('seleniumBasePath');

        // make sure target path exists
        if (seleniumPath && xfs.existsSync(seleniumPath.path)) {
            jsonPath = seleniumPath.join('selenium-config.json');
            loggingPropertiesPath = seleniumPath.join('logging.properties');

            // if jsonPath isn't valid, we need an install
            if (!jsonPath || !xfs.existsSync(jsonPath.path)) {
                needsInstall = true;
            } else if (!loggingPropertiesPath || !xfs.existsSync(loggingPropertiesPath.path)) {
                needsInstall = true;
            } else {
                // if it exists, try to read config file
                config = Json.readSync(jsonPath.path);
            }
        } 
        // no target, we need an install
        else {
            needsInstall = true;
        }

        return new Promise(function (resolve, reject) {
            // if we need an install, we'll read from local json file, use it's data
            // and then copy the resources to the correct location
            // since opts is passed through, this can conceivably support alternate locations

            if (needsInstall) {
                var jsonPath = seleniumPath.join('selenium-config.json'),
                    loggingPropertiesPath = seleniumPath.join('logging.properties'),
                    jarDir = seleniumPath.join('selenium-server'),
                    chromeDir = seleniumPath.join('chromedriver'),
                    seleniumSource = xfs.filesDir.join('selenium'),
                    jsonSource = seleniumSource.join('selenium-config.json'),
                    jarSource, chromeSource, chromeName, jarName, jarPath, chromePath;

                // read the default configuration
                me.seleniumConfig = Json.readSync(jsonSource.path);
                // make sure we have the necessary paths setup
                jarDir.ensurePathExistsSync();
                chromeDir.ensurePathExistsSync();
                // create locations and variables for the copy ops for selenium server jar
                jarName = me.getSeleniumServerJarName(me.seleniumConfig.hub.version);
                jarPath = jarDir.join(jarName);
                jarSource = seleniumSource.join('selenium-server').join(jarName);
                // create locations and variables for the copy ops for chrome driver
                chromeName = me.getChromeDriverName(me.seleniumConfig.node.drivers.chrome.version);
                chromePath = chromeDir.join(chromeName);
                chromeSource = seleniumSource.join('chromedriver').join(chromeName);

                // copy jar
                xfs.copy(jarSource, jarPath)
                    // copy chrome
                    .then(function () {
                        return xfs.copy(chromeSource, chromePath);
                    })
                    // fix perms on driver for mac/linux
                    .then(function () {
                        return fs.chmod(chromePath.path, '0755');
                    })
                    // copy config file
                    .then(function () {
                        return xfs.copy(seleniumSource.join('selenium-config.json'), jsonPath);
                    })
                    // copy logging config
                    .then(function () {
                        return xfs.copy(seleniumSource.join('logging.properties'), loggingPropertiesPath);
                    })                        
                    // resolve
                    .then(function () {
                        resolve();
                    });
            } else {
                me.seleniumConfig = config;
                resolve();
            }
        });
    }

    startHub () {
        var me = this,
            seleniumPath = me.seleniumBasePath,
            config = me.hubConfig;        

        return new Promise(function (resolve, reject) {
            selenium.start(config, function (err, child) {
                if (err) {
                    reject(err);
                } else {
                    me.seleniumHub = child;
                    resolve(me);
                }
            });
        });
    }

    startNode (hubHost, hubPort) {
        var me = this,
            hubHost = hubHost || 'http://localhost',
            hubPort = hubPort || 4444,
            hubUrl = util.format('%s:%s/grid/register', hubHost, hubPort),
            seleniumPath = me.seleniumBasePath,
            config = me.nodeConfig;

        return new Promise(function (resolve, reject) {
            config.seleniumArgs = ['--', '-role', 'node', '-hub', hubUrl];
            
            selenium.start(config, function (err, child) {
                if (err) {
                    reject(err);
                } else {
                    me.seleniumNode = child;
                    resolve(child);
                }                    
            });
        });
    }
        
    _installSelenium () {
        var me = this,
            task = new Task();
        
        task.setDescription('Selenium Installer');
        
        return new Promise(function (resolve, reject) {
            selenium.install({
                basePath: me.seleniumBasePath.path
            }, function (err, drivers) {
                if (err) {
                    task.error(err)
                } else {
                    let message = JSON.stringify(drivers, null, 4);
                    message.split('\n').forEach((line) => {
                        task.debug(line);
                    })
                }
                task.done();
                resolve();
            });
        });
    }
    
    _startStandaloneServer () {
        var me = this,
            task = me._getStandaloneServerTask();
        
        return new Promise(function (resolve, reject) {
            if (task.running) {
                resolve(task);
            } else {
                task.on({
                    scope: me,
                    single: true,
                    running: function () {
                        resolve(task);
                    }
                });
                
                task.on({
                    scope: me,
                    single: true,
                    error: function (e) {
                        reject(e.error);
                    }
                });
            }
        });
    }
    
    _getStandaloneServerTask () {
        var me = this,
            task = me._task;
        
        if (!task) {
            task = me._task = new ChildProcessTask({
                description: 'Selenium Server',
                
                launchProcess: me._startSelenium.bind(me),
               
                // Java logger writes everything to stderr
                onStderrData: function (data) {
                    this.onStdoutData(data);
                }
            });
            
            me.onTaskStart(task);

            task.on({
                scope: me,
                complete: function() {
                    me.onTaskStop();
                    me._task = null;
                }
            });
        }
        
        return task;
    }
    
    _startSelenium () {
        var me = this;
        return new Promise(function (resolve, reject) {
            portfinder.basePort = 4450;
            portfinder.getPort(function (err, port) {
                var config = me.nodeConfig;
                
                me._task.setDescription('Selenium Server @ ' + port);
                me.set('port', port);
                config.seleniumArgs = ['-port', port || 4450];

                selenium.start(config, function (err, child) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(child);
                    }
                });
            });
        });
    }

    start () {
        var me = this;
        
        return me._scaffoldSelenium().then(function () {
            return true;
            //return me._installSelenium();
        }).then(function () {
            return me._startStandaloneServer();
        });
    }
    
    stop () {
        var me = this,
            task = me._task;
        
        if (task) {
            task.stop();
        }
    }
}

module.exports = Embedded;
