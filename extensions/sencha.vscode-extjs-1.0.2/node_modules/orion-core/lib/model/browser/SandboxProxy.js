'use strict';


const Browser = require('orion-core/lib/model/browser/Local');
const SelfSpawner = require('orion-core/lib/process/SelfSpawner');
const xfs = require('orion-core/lib/xfs');

const console = require('orion-core/lib/util/console-manager').console;

const allowedMessages = {
    sandboxCreated: 1,
    sandboxReady: 1,
    sandboxClosed: 1,
    sandboxTerminated: 1
}

class SandboxProxy extends Browser {
    
    static get meta () {
        return {
            mixins: [
                SelfSpawner
            ],
            
            prototype: {
                isSandbox: true,
                isDebuggable: true,
                portSeed: 9222
            }
        };
    }
    
    get devToolsPort () {
        var me = this;
        return me._devToolsPort || (me._devToolsPort = me.portSeed++);
    }
    
    constructor (config) {
        super(Object.assign({
            description: 'Sandbox',
            version: process.version.chrome,
            profile: '',
            type: 'chromium',
            detected: true
        }, config));
    }
    
    launch () {
        var me = this;
        
        return new Promise (function (resolve, reject) {
            me.mixins.selfSpawner.spawn.call(me);
            me._resolveLaunch = resolve;
        });
    }
    
    // -----------------
    // SelfSpawner begin
    // -----------------
    getSpawnSwitches () {
        return [
            '--sandbox',
            '--remote-debugging-port=' + this.devToolsPort
        ];
    }
    
    getChildProcessDescription () {
        return 'Sencha Test Sandbox';
    }
    
    onTaskRunning () {
        var me = this,
            proc = me.task.proc;
        
        proc.on('message', function (m) {
            var type = m.type || m;
            if (allowedMessages[type]) {
                me.fire(type, m);
                if (me[type]) {
                    me[type](m);
                }
            }
        });
        
        proc.send({
            type: 'run',
            url: me.get('url'),
            devtoolsPort: me.devToolsPort,
            proxyPort: me.get('proxyPort')
        });
        
        me._resolveLaunch(me.task);
    }
    
    onTaskComplete () {
        
    }
    
    // ---------------
    // SelfSpawner end
    // ---------------
    
    screenshot (args) {
        var me = this;
        return new Promise(function (resolve, reject) {
            me._screenshotResolve = resolve;
            me.task.proc.send({
                type: 'screenshot'
            });
        });
    }
    
    terminate () {
        var me = this;
        me.task.proc.send({
            type: 'terminate'
        });
    }
    
    getDriverConfig () {
        var browser = this.get('browser'),
            browserData = browser.data,
            farm = browser.pool.farm;
        
        return farm.driverConfig(browserData);
    }

}

module.exports = SandboxProxy;
