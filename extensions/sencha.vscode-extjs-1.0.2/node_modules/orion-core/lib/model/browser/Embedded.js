'use strict';


const LocalBrowser = require('orion-core/lib/model/browser/Local');
const SelfSpawner = require('orion-core/lib/process/SelfSpawner');

const console = require('orion-core/lib/util/console-manager').console;

const allowedMessages = {
    windowCreated: 1,
    windowLoaded: 1,
    windowClosed: 1
}

class Embedded extends LocalBrowser {
    
    static get meta () {
        return {
            mixins: [
                SelfSpawner
            ],
            
            prototype: {
                isEmbeddedBrowser: true
            }
        };
    }
    
    constructor (config) {
        super(Object.assign({
            description: 'Chromium (embedded)',
            version: process.versions.chrome,
            profile: '',
            type: 'chromium',
            name: 'Chrome',
            detected: true
        }, config));
    }
    
    ctor () {
        this.set('command', this.execPath);
    }
    
    get isRunning () {
        return this._running;
    }
    
    get execPath () {
        var me = this;
        return me.mixins.selfSpawner.getExecPath.call(me);
    }
    
    launch (opts) {
        var me = this;
        
        if (typeof opts === 'string') {
            opts = {
                url: opts
            };
        }
        me._url = opts.url;
        
        return me.mixins.selfSpawner.spawn.call(me);
    }
    
    // -----------------
    // SelfSpawner begin
    // -----------------
    getSpawnSwitches () {
        return ['--embedded'];
    }
    
    getChildProcessDescription () {
        return 'Chromium';
    }
    
    onTaskRunning () {
        var me = this,
            proc = me.task.proc;
        
        proc.on('message', function (m) {
            var type = m.type || m;
            // console.log('Received: %s', type);
            if (allowedMessages[type]) {
                // console.log('Firing: %s', type);    
                me.fire(type, m);
                if (me[type]) {
                    me[type](m);
                }
            }
        });
        
        proc.send({
            type: 'run',
            url: me._url, // received as launch argument
            proxyPort: me.get('proxyPort')
        });
    }
    
    onTaskComplete () {
        var me = this;
        me._running = false;
        me.fire({
            type: 'terminated',
            browser: me
        });
    }
    // ---------------
    // SelfSpawner end
    // ---------------
    
    screenshot (args) {
        var me = this;
        return new Promise(function (resolve, reject) {
            me._screenshotResolve = resolve;
            me.task.proc.send({
                type: 'screenshot'
            });
        });
    }
    
    terminate () {
        var me = this;
        me.task.stop();
        me.fire({
            type: 'terminated',
            browser: me
        });
    }

    canPersist () {
        return !this.data.detected;
    }
}

module.exports = Embedded;
