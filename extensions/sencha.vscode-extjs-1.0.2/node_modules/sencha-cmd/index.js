/**
 * Sencha Cmd Module
 */
'use strict';

const EventEmitter = require('events'),
	  child_process = require('child_process'),
	  spawn = child_process.spawn,
	  execSync = child_process.execSync,
	  kill = require('tree-kill'),
	  semver = require('semver');

const SenchaCmdError = require('./errors/SenchaCmdError'),
      SenchaCmdVersionError = require('./errors/SenchaCmdVersionError'),
      SenchaCmdNotFoundError = require('./errors/SenchaCmdNotFoundError');

let logger = require('log4js').getLogger();

// Various REGEX's to match to lines reported
// by Cmd.
const MESSAGE_REGEX = /\[INF]\s*(.*)/;
const ERROR_REGEX   = /\[ERR]\s*(.*)/;
const COMP_REGEX    = /Waiting for changes/;
const PORT_REGEX    = /Server started at port.*:\s*(\d*)/;
const ROOT_REGEX    = /Mapping http:\/\/.*:\d*\/ to (.*)\.{3}/;

const SUPPORTED_CMD_VERSION = '>=6.2.0';

// Not sure if needed...(electron specific??)
const PROCESSES = {};

let CMD_PATH = null;

const OS = require('os').platform();

if (OS !== 'win32') {
    try {
        const lines = execSync(process.env.SHELL + ' -lc export').toString('utf8').split(/\n/);

        for (let line of lines) {
            const parts = line.replace(/^declare -x /, '').split('=');
            if (parts.length === 2) process.env[parts[0]] = parts[1].replace(/"/g, '');
        }
    } catch (e) {
        console.log('Could not import environment variables from shell', e);
    }
}

class SenchaCmd extends EventEmitter {
    /**
     * @param args {Array} Array of string arguments to pass to 'sencha'
     * @param options {Object} Other options to pass to 'spawn' of process.
     */
	constructor (args, options) {
		super ();
		this.args = args;
		this.options = options || {};
		this.errors = [];
		this.messages = [];
	}

	/**
	 * Sets the logger to use.
	 * @param {log4j} logger A log4js logger to use
	 */
	static setLogger(l) {
		logger = l;
	}

	/**
	 * Override to set command path
	 */
	static setCmdPath (path) {
		CMD_PATH = path;
	}

    /**
     * Get's the executable for Sencha Cmd from UserSettings (defaults to 'sencha' to use what's in shell's PATH).
     * @returns {*}
     */
	static getCmd () {
		return CMD_PATH || 'sencha';
	}

    /**
     * Convenience method to get executable for Sencha Cmd.
     * @returns {*}
     */
	get sencha () {
		return SenchaCmd.getCmd();
	}

    /**
     * Gets any currently running Cmd processes.
     * @returns {{}}
     */
	static getProcesses () {
		return PROCESSES;
	}

    /**
     * Determines the version of Cmd on this system.
     * @returns {*}
     */
	static cmdVersion (cmdLocation = SenchaCmd.getCmd()) {
		const cmd = `${cmdLocation} switch --list`;
		try {
			const output = execSync(cmd).toString();
			logger.debug(`"${cmd}" output: ${output}`);
			return output.match(/Sencha Cmd v?(\d+\.\d+\.\d+)/)[1];
		} catch (e) {
			logger.error(`Error executing ${cmd}`, e.message, e.stack);
		}
	}

    /**
     * Returns true if the minimum required version of Sencha Cmd is installed
     * @returns {Boolean}
     */
    static verifyRequiredVersionInstalled(cmdLocation) {
        const installed = SenchaCmd.cmdVersion(cmdLocation);

        if(semver.satisfies(installed, SUPPORTED_CMD_VERSION)) {
            return true;
        } else {
            throw new SenchaCmdVersionError(SUPPORTED_CMD_VERSION, installed);
        }
    }

    /**
     * Allows for chaining of commands together, so the progress will span
     * the entire chain of commands, instead of just one at a time.
     *
     * This can be used in combination with toPromise() to build a chain that resolves
     * a Promise after the entire chain is complete.
     *
     * @param args {Array|SenchaCmd} Arguments to generate new SenchaCmd or a SenchaCmd to chain next.
     * @param options {Object} Other options to pass to 'spawn' of process.
     * @returns {SenchaCmd|*} The SenchaCmd representing the next command to run.
     */
    then(args, options) {
        this.next = args instanceof SenchaCmd ? args : new SenchaCmd(args, options);
        this.next.prev = this;

        return this.next;
    }

    /**
     * Converts this SenchaCmd to a Promise that resolves with properties
     * from execution (messages, errors, port (if applicable), etc.)
     * @returns {Promise}
     */
    toPromise() {
        return new Promise((resolve, reject) => {
            this.start();
            this.once('success', () => resolve(this._toObj()) );
            this.once('error', err => reject(err));
        });
    }

    start() {
        if(this.prev && !this.prev.complete) {
            this.prev.once('success', this._spawn.bind(this));
            this.prev.start();
        } else {
            this._spawn();
        }
    }

    /**
     * Set to false when stopping cmd following an error
     * @param {Boolean} [stoppedByUser=true]
     * @returns {Promise}
     */
    stop(stoppedByUser=true) {
        return new Promise(resolve => {
            if(this.process && this.process.pid) {
                this.stoppedByUser = stoppedByUser;
                kill(this.process.pid, 'SIGKILL', () => {
                    resolve();
                });
            } else if(this.prev) {
                this.prev.stop().then(resolve.bind(null));
            } else {
                resolve();
            }
        });
    }

    /**
     * Spawns a process to execute this SenchaCmd. Also links handlers
     * to process' events.
     * @returns {*|Ext.data.Session}
     * @private
     */
    _spawn() {
        this.process = spawn(this.sencha, this.args, this.options);
        PROCESSES[this.process.pid] = this;
        this.emit('start', this.process);
        this.process.once('close', this._closeHandler.bind(this));
        this.process.stdout.on('data', this._dataHandler.bind(this));
        this.process.stderr.on('data', data => logger.debug(data.toString()));
        return this.process;
    }

    /**
     * Resolving to an instance of an ES6 class in a Promise silently fails,
     * this will copy the important properties of this object to a plain JS object
     * to be resolved to a promise.
     * @returns {Object}
     * @private
     */
    _toObj() {
        return Object.assign({}, this);
    }

    /**
     * Handler for the 'close' event of the process.
     * @param code
     * @private
     */
    _closeHandler(code) {
        delete PROCESSES[this.process.pid];

        if(code === 0 && this.errors.length <= 0) {
            logger.debug(this.args.join(' '), 'stopped with code', code);
            this.emit('success');
        } else if(!this.stoppedByUser) {
            logger.error(this.args.join(' '), 'died with code', code, this.errors);

            // Only emit error/failure if we weren't killed by the user.
            this.emit('error', new SenchaCmdError(this));
        }
    }

    _stopOnError() {
        return this.args.join(' ').indexOf('app watch') === 0;
    }

    /**
     * Handler for the stdout 'data' event of the process.
     * @param data
     * @private
     */
    _dataHandler(data) {
        let dataStr = data.toString(),
            lines = dataStr.split('\n');

        lines.forEach(str => {
            if (str.length) logger.info(str); // send all messages to the log for debugging purposes
            let match;
            this.messages.push(str);

            this.emit('message', str);

            if (match = str.match(ERROR_REGEX)) {
                this.errors.push(match[1]);

                if (!this.success && this._stopOnError()) {
                    this.stop(false)
                }
            }

            if (str.match(COMP_REGEX)) {
                this.success = true;
                this.emit('success');
            }

            if (match = str.match(PORT_REGEX)) {
                this.port = match[1];
            }

            if (match = str.match(ROOT_REGEX)) {
                this.root = match[1];
            }
        });
    }
}

module.exports = SenchaCmd;
